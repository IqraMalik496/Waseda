# Introduction to Bioinformatics

## What is bioinformatics?

“Bioinformatics…is the discipline of quantitative analysis of information relating to 
biological macromolecules with the aid of computers.”

“…bioinformatics involves the technology that uses computers for storage, retrieval, 
manipulation, and distribution of information related to biological macromolecules such 
as DNA, RNA, and proteins.”

(Jin Xiong, Essential Bioinformatics, Cambridge University Press: 2006.)


“At its core, bioinformatics is the extraction of biological information (or meaning) from 
biological data stored in databases.  All other topics and questions in bioinformatics, 
such as how biological data are collected and stored, how protein structure and function 
can be predicted from sequence data, or how metabolic networks may be visualized, can 
be understood in relation to this primary concept.”

(B.S. Chapman, J.L. Christmann, and E.F. Thatcher “Bioinformatics for Undergraduates” 
Biochem. Mol. Biol. Educ. (2006) 34:180-186.)


“Bioinformatics represents a new field at the interface of the twentieth-century 
revolutions in molecular biology and computers.  A focus of this new discipline is the 
use of computer databases and computer algorithms to analyze proteins, genes, and the 
complete collection of deoxyribonucleic acid (DNA) that comprises an organism (the 
genome).”

(Jonathan Pevsner, Bioinformatics and Functional Genomics, John Wiley & Sons, Inc.: 2003.)


“…the term ‘bioinformatics’ refers to the task of organizing, analyzing, and predicting 
increasingly complex data arising from modern molecular and biochemical techniques.”

(Lukas K. Buehler and Hooman H. Rashidi, eds., Bioinformatics Basics, 2nd ed., Taylor & 
Francis Group, LLC: 2005.)

Recurring Theme:  
Bioinformatics = analyzing sequences and structures of biomolecules







## Bioinformatics involves the analysis of the sequences and
structures of biological macromolecules (DNA, RNA, proteins):

“…the discipline of bioinformatics focuses on the analysis of molecular sequences.” 

“A bioinformatics approach to molecular sequence data involves the application of 
computer algorithms and computer databases to molecular and cellular biology.”

(Jonathan Pevsner, Bioinformatics and Functional Genomics, John Wiley & Sons, Inc.: 2003.)


“The bread-and-butter of bioinformatics are gene sequences and protein structures.”

“Nucleic acid sequences and protein structures are the raw data that bioinformaticians 
use to find relations among genes, genomes, and proteins.”
 
(Lukas K. Buehler and Hooman H. Rashidi, eds., Bioinformatics Basics, 2nd ed., Taylor & 
Francis Group, LLC: 2005.)


## Bioinformatics is an interdisciplinary field.  

Researchers from any of these fields might be involved in the development and/or use of bioinformatics tools and techniques:
	molecular biology
	genetics
	biochemistry
	other biological sciences
	computer science
	mathematics
	statistics
	
## Why is a bioinformatics approach necessary and useful?

“[Bioinformatics] provides useful interpretation of experimental data and important
leads for further experimental research.”

“The ultimate goal of bioinformatics is to better understand a living cell and how it 
functions at the molecular level.  By analyzing raw molecular sequence and structural 
data, bioinformatics research can generate new insights and provide a ‘global’ 
perspective of the cell.”

(Jin Xiong, Essential Bioinformatics, Cambridge University Press: 2006.)


“Today, bioinformatics is driven by the challenge of integrating the large amount of 
genetic and structural data emanating from biomedical research.  Using computational 
power bioinformaticians catalog and compare genetic and structural information with 
biochemical, physiological, and medical data furthering our understanding of the cellular 
organization of life, [and] its diversity…”

(Lukas K. Buehler and Hooman H. Rashidi, eds., Bioinformatics Basics, 2nd ed., Taylor & 
Francis Group, LLC: 2005.)


The bottom line:  (1) integration of diverse experimental data to give a more global perspective;  (2) generation of ideas for further experimental work

## Limitations of bioinformatics predictions:

“Bioinformatics predictions are not formal proofs of any concepts.  They do not replace
the traditional experimental research methods of actually testing hypotheses.”

(Jin Xiong, Essential Bioinformatics, Cambridge University Press: 2006.)


“…the quality of bioinformatics predictions depends on the quality of data and the 
sophistication of the algorithms being used.”

(Jin Xiong, Essential Bioinformatics, Cambridge University Press: 2006.)


“The quality and accuracy of the data is crucial in order to correctly interpret their 
biological significance.”

(Lukas K. Buehler and Hooman H. Rashidi, eds., Bioinformatics Basics, 2nd ed., Taylor & 
Francis Group, LLC: 2005.)

## A very brief history of bioinformatics:

1965 	Margaret Dayhoff and collaborators at National Biomedical Research
              Foundation develop first protein sequence database

1970	Saul Needleman and Christian Wunsch develop first sequence 
              alignment algorithm

1974	Chou and Fasman develop first protein structure prediction algorithm

~1979	GenBank established as a nucleic acid sequence database at Los 
              Alamos National Laboratory

1987	Perl computer programming language released by Larry Wall

1988	National Center for Biotechnology Information (NCBI) is established 
              at NIH/NLM

1990	Stephen Altschul develops BLAST for searching sequence databases

mid-90s	The term “bioinformatics” becoming widely used

1995	First bacterial genomes sequenced

2001	Human genome sequence is published




## Examples of some “real-world” problems to which
scientists could apply bioinformatics:

1.  The genome of a particular organism has been sequenced…
Scientists can use bioinformatics tools to “find” the genes within the genome sequence and determine the sequences of the proteins these genes encode.

2.  A new gene has been cloned from a particular organism…
Scientists can use bioinformatics tools to predict a potential function for the protein encoded by this gene.

3.  The amino acid sequence of a particular protein is known…
Scientists can use bioinformatics tools to predict a potential structure for this protein.

4.  Based on a microarray experiment, a specific set of genes is “upregulated” in an organism under a specific set of conditions…
Scientists can use bioinformatics tools to determine what all these genes have in common and what biological pathways they belong to.

5.  A very large amount of sequence data has been generated by a set of experiments…
Scientists can use bioinformatics methods to store, organize, and access this data.



# Molecular Biology Primer

## How Molecular Biology came about?
Microscopic biology began in 1665

Robert Hooke (1635-1703) discovered organisms are made up of cells

Matthias Schleiden (1804-1881) and Theodor Schwann (1810-1882) further expanded the study of cells in 1830s

## Major events in the history of Molecular Biology   1800 - 1870

1865   Gregor Mendel discover the basic rules of heredity of garden pea.
An individual organism has two alternative heredity units for a given trait (dominant trait  v.s. recessive trait)


1869 Johann Friedrich Miescher discovered DNA and named it nuclein.

## Major events in the history of Molecular Biology  1880 - 1900

1881 Edward Zacharias showed chromosomes are composed of nuclein.

1899 Richard Altmann renamed nuclein to nucleic acid.

By 1900, chemical structures of all 20 amino acids had 
been identified


## Major events in the history of Molecular Biology 1900-1911
1902 - Emil Hermann Fischer wins Nobel prize: showed amino acids are linked and form proteins
Postulated: protein properties are defined by amino acid composition and arrangement, which we nowadays know as fact


1911 – Thomas Hunt Morgan discovers genes on chromosomes are the discrete units of heredity


1911 Pheobus Aaron Theodore Lerene discovers RNA

## Major events in the history of Molecular Biology 1940 - 1950

1941 – George Beadle and Edward Tatum identify that genes make proteins




1950 – Edwin Chargaff find Cytosine complements Guanine and Adenine complements Thymine


## Major events in the history of Molecular Biology  1950 - 1952


1950s – Mahlon Bush Hoagland first to isolate tRNA





1952 – Alfred Hershey and Martha Chase make genes from DNA 

## Major events in the history of Molecular Biology 1970
1970  Howard Temin and David Baltimore independently isolate the first restriction enzyme

DNA can be cut into reproducible pieces with site-specific endonuclease called restriction enzymes; 
the pieces can be linked to bacterial vectors and introduced into bacterial hosts.  (gene cloning or recombinant DNA technology)
## Major events in the history of Molecular Biology 1970- 1977

1977 Phillip Sharp and Richard Roberts demonstrated that pre-mRNA is processed by the excision of introns and exons are spliced together.

Joan Steitz determined that the 5’ end of snRNA is partially complementary to the consensus sequence of 5’ splice junctions.

## Major events in the history of Molecular Biology 1986 - 1995

1986 Leroy Hood: Developed automated sequencing mechanism

1986 Human Genome Initiative announced

1990 The 15 year Human Genome project is launched by congress

1995 Moderate-resolution maps of chromosomes 3, 11, 12, and 22 maps published (These maps provide the locations of “markers” on each chromosome to make locating genes easier)

## Major events in the history of Molecular Biology 1995-1996

1995  John Craig Venter: First bactierial genomes sequenced

1995  Automated fluorescent sequencing instruments and robotic operations 

1996  First eukaryotic genome-yeast-sequenced

## Major events in the history of Molecular Biology 1997 - 1999

1997 E. Coli sequenced

1998   PerkinsElmer, Inc.. Developed 96-capillary sequencer

1998   Complete sequence of the Caenorhabditis elegans genome

1999 First human chromosome (number 22) sequenced
## Major events in the history of Molecular Biology 2000-2001
2000   Complete sequence of the euchromatic portion of the Drosophila melanogaster genome

2001 International Human Genome Sequencing:first  draft of the sequence of the human genome published


## Major events in the history of Molecular Biology 2003- Present
April 2003 Human Genome Project Completed.  Mouse genome is sequenced.

April 2004 Rat genome sequenced.

## Section1: What is Life made of?

### Cells
Fundamental working units of every living system. 
Every organism is composed of one of two 
     radically different types of cells: 
     prokaryotic cells or 
     eukaryotic cells.
Prokaryotes and  Eukaryotes are descended from the same primitive cell.  
All extant prokaryotic and eukaryotic cells  are the result of a total of 3.5 billion years of evolution.
Chemical composition-by weight 
70% water
7% small molecules
 salts
Lipids
amino acids
nucleotides
23% macromolecules
Proteins
Polysaccharides
lipids
biochemical (metabolic) pathways
translation of mRNA into proteins
### Life begins with Cell
A cell is a smallest structural unit of an organism that is capable of independent functioning
All cells have some common features
### All Cells have common Cycles

### Two types of cells: Prokaryotes and Eukaryotes
### Prokaryotes and Eukaryotes
According to the most recent evidence, there are three main branches to the tree of life. 
Prokaryotes include Archaea (“ancient ones”) and bacteria.
Eukaryotes are kingdom Eukarya and includes plants, animals, fungi and certain algae.

### Prokaryotes vs Eukaryotes 

#### Structural differences
Prokaryotes
Eubacterial (blue green algae) 
      and archaebacteria
only one type of membrane--
     plasma membrane forms 
the boundary of the cell proper 
The smallest cells known are bacteria
Ecoli cell
3x106 protein molecules
1000-2000 polypeptide species.

Eukaryotes
plants, animals, Protista, and fungi

complex systems of internal membranes forms 
organelle and compartments 
The volume of the cell is several hundred times larger
Hela cell
5x109 protein molecules
5000-10,000 polypeptide species
#### Chromosomal differences

Prokaryotes
The genome of E.coli contains amount of t 4X106 base pairs
> 90% of DNA encode protein


Lacks a membrane-bound nucleus. 
Circular DNA and supercoiled
      domain
Histones are unknown 

Eukaryotes
The genome of yeast cells contains
       1.35x107 base pairs
A small fraction of the total DNA encodes protein.
Many repeats of non-coding sequences
All chromosomes are contained in a membrane bound nucleus
DNA is divided between two or more chromosomes	
A set of five histones 
DNA packaging and gene expression regulation

### Signaling Pathways: Control Gene Activity 
Instead of having brains, cells make decision through complex networks of chemical reactions, called pathways
Synthesize new materials
Break other materials down for spare parts
Signal to eat or die
### Example of cell signaling
### Cells Information and Machinery
Cells store all information to replicate itself
Human genome is around 3 billions base pair long
Almost every cell in human body contains same set of genes
But not all genes are used or expressed by those cells
Machinery:
Collect and manufacture components
Carry out replication
Kick-start its new offspring
(A cell is like a car factory)

### Overview of organizations of life
Nucleus = library
Chromosomes = bookshelves
Genes = books
Almost every cell in an organism contains the same libraries and the same sets of books.
Books represent all the information (DNA) that every cell in the body needs so it can grow and carry out its vaious functions.
### Some Terminology
Genome: an organism’s genetic material

Gene: a discrete units of hereditary information located on the     chromosomes and consisting of DNA.

Genotype: The genetic makeup of an organism

Phenotype: the physical expressed traits of an organism

Nucleic acid: Biological molecules(RNA and DNA) that allow organisms to reproduce;
### More Terminology
The genome is an organism’s complete set of DNA.
a bacteria contains about 600,000 DNA base pairs
human and mouse genomes have some 3 billion.
human genome has 24 distinct chromosomes.
Each chromosome contains many genes. 
Gene 
basic physical and functional units of heredity. 
specific sequences of DNA bases that encode instructions on how to make proteins. 
Proteins 
Make up the cellular structure
large, complex molecules made up of smaller subunits called amino acids. 
### All Life depends on 3 critical molecules
DNAs
Hold information on how cell works
RNAs
Act to transfer short pieces of information to different parts of cell
Provide templates to synthesize into protein
Proteins
Form enzymes that send signals to other cells and regulate gene activity
Form body’s major components (e.g. hair, skin, etc.)

# Genomics and Its Impact on Science and Society: The Human Genome Project and Beyond

## Human Genome Project
In 2003 scientists in the Human Genome Project achieved a long-sought goal by obtaining the DNA sequence of the 3.2 billion base pairs (the order of As, Ts, Cs, and Gs) making up the human genome. The DNA sequence spells out the exact instructions needed to maintain and reproduce a living organism – whether it’s a person, a plant, or a paramecium.
 
Some fascinating insights so far:
-         The human genome is almost (99.9%) exactly the same in all people.
-         Only 2% of the human genome contains genes, the part of DNA that encodes recipes for proteins. We don’t know what the remainder does.
-         We have an estimated 30,000-40,000 genes; the functions remain unknown for more than half of these.
-         Almost half of all proteins predicted from human genes share similarities with fruit flies and worms, underscoring the unity of life.
 
-         MUCH remains to be learned! 


Goals: 
■ identify all the approximate 30,000 genes in human DNA, 
■ determine the sequences of the 3 billion chemical base pairs that make up human DNA, 
■ store this information in databases, 
■ improve tools for data analysis, 
■ transfer related technologies to the private sector, and 
■ address the ethical, legal, and social issues (ELSI) that may arise from the project. 
 
Milestones:
■ 1990: Project initiated as joint effort of U.S. Department of Energy and the National Institutes of Health ■ June 2000: Completion of a working draft of the entire human genome 
■ February 2001: Analyses of the working draft are published
■ April 2003: HGP sequencing is completed and Project is declared finished two years ahead of schedule

## What does the draft human genome sequence tell us? 
By the Numbers
• The human genome contains 3 billion chemical nucleotide bases (A, C, T, and G). 
• The average gene consists of 3000 bases, but sizes vary greatly, with the largest known human gene being dystrophin at 2.4 million bases.
 • The total number of genes is estimated at around 30,000--much lower than previous estimates of 80,000 to 140,000.
 • Almost all (99.9%) nucleotide bases are exactly the same in all people.
 • The functions are unknown for over 50% of discovered genes.



## What does the draft human genome sequence tell us?
How It's Arranged
• The human genome's gene-dense "urban centers" are predominantly composed of the DNA building blocks G and C.
 
• In contrast, the gene-poor "deserts" are rich in the DNA building blocks A and T. GC- and AT-rich regions usually can be seen through a microscope as light and dark bands on chromosomes.
 
• Genes appear to be concentrated in random areas along the genome, with vast expanses of noncoding DNA between.
 
• Stretches of up to 30,000 C and G bases repeating over and over often occur adjacent to gene-rich areas, forming a barrier between the genes and the "junk DNA." These CpG islands are believed to help regulate gene activity.
 
• Chromosome 1 has the most genes (2968), and the Y chromosome has the fewest (231). 

The Wheat from the Chaff

• Less than 2% of the genome codes for proteins.
 
• Repeated sequences that do not code for proteins ("junk DNA") make up at least 50% of the human genome.
 
• Repetitive sequences are thought to have no direct functions, but they shed light on chromosome structure and dynamics. Over time, these repeats reshape the genome by rearranging it, creating entirely new genes, and modifying and reshuffling existing genes.
 
• The human genome has a much greater portion (50%) of repeat sequences than the mustard weed (11%), the worm (7%), and the fly (3%).

How the Human Compares with Other Organisms• Unlike the human's seemingly random distribution of gene-rich areas, many other organisms' genomes are more uniform, with genes evenly spaced throughout.
 • Humans have on average three times as many kinds of proteins as the fly or worm because of mRNA transcript "alternative splicing" and chemical modifications to the proteins. This process can yield different protein products from the same gene. 
 • Humans share most of the same protein families with worms, flies, and plants; but the number of gene family members has expanded in humans, especially in proteins involved in development and immunity.
 • Although humans appear to have stopped accumulating repeated DNA over 50 million years ago, there seems to be no such decline in rodents. This may account for some of the fundamental differences between hominids and rodents, although gene estimates are similar in these species. Scientists have proposed many theories to explain evolutionary contrasts between humans and other organisms, including those of life span, litter sizes, inbreeding, and genetic drift. 

Variations and Mutations
• Scientists have identified about 3 million locations where single-base DNA differences (SNPs) occur in humans. This information promises to revolutionize the processes of finding chromosomal locations for disease-associated sequences and tracing human history.
 
• The ratio of germline (sperm or egg cell) mutations is 2:1 in males vs females.  Researchers point to several reasons for the higher mutation rate in the male germline, including the greater number of cell divisions required for sperm formation than for eggs. 

Variations and Mutations
• Scientists have identified about 3 million locations where single-base DNA differences (SNPs) occur in humans. This information promises to revolutionize the processes of finding chromosomal locations for disease-associated sequences and tracing human history.
 
• The ratio of germline (sperm or egg cell) mutations is 2:1 in males vs females.  Researchers point to several reasons for the higher mutation rate in the male germline, including the greater number of cell divisions required for sperm formation than for eggs. 

## How does the human genome stack up?

## Future Challenges: What We Still Don’t Know
• Gene number, exact locations, and functions 
• Gene regulation 
• DNA sequence organization
• Chromosomal structure and organization 
• Noncoding DNA types, amount, distribution, information content, and functions 
• Coordination of gene expression, protein synthesis, and post-translational events 
• Interaction of proteins in complex molecular machines
• Predicted vs experimentally determined gene function
• Evolutionary conservation among organisms
• Protein conservation (structure and function)
• Proteomes (total protein content and function) in organisms
• Correlation of SNPs (single-base DNA variations among individuals) with health and disease
• Disease-susceptibility prediction based on gene sequence variation
• Genes involved in complex traits and multigene diseases
• Complex systems biology including microbial consortia useful for environmental restoration
• Developmental genetics, genomics 


## Anticipated Benefits of Genome Research
Molecular Medicine 
• improve diagnosis of disease• detect genetic predispositions to disease• create drugs based on molecular information• use gene therapy and control systems as drugs• design “custom drugs” (pharmacogenomics) based on individual genetic profiles 
Microbial Genomics
• rapidly detect and treat pathogens (disease-causing microbes) in clinical practice• develop new energy sources (biofuels)• monitor environments to detect pollutants• protect citizenry from biological and chemical warfare• clean up toxic waste safely and efficiently

Risk Assessment 
• evaluate the health risks faced by individuals who may be exposed to radiation (including low levels in industrial areas) and to cancer-causing chemicals and toxins
Bioarchaeology, Anthropology, Evolution, and Human Migration
• study evolution through germline mutations in lineages• study migration of different population groups based on maternal inheritance• study mutations on the Y chromosome to trace lineage and migration of males• compare breakpoints in the evolution of mutations with ages of populations and historical events 

DNA Identification (Forensics)
• identify potential suspects whose DNA may match evidence left at crime scenes• exonerate persons wrongly accused of crimes• identify crime and catastrophe victims• establish paternity and other family relationships• identify endangered and protected species as an aid to wildlife officials (could be used for prosecuting poachers)• detect bacteria and other organisms that may pollute air, water, soil, and food• match organ donors with recipients in transplant programs• determine pedigree for seed or livestock breeds• authenticate consumables such as caviar and wine
 
Agriculture, Livestock Breeding, and Bioprocessing 
• grow disease-, insect-, and drought-resistant crops• breed healthier, more productive, disease-resistant farm animals• grow more nutritious produce• develop biopesticides• incorporate edible vaccines incorporated into food products• develop new environmental cleanup uses for plants like tobacco 


## Medicine and the New Genetics
Gene Testing   /  Pharmacogenomics   /   Gene Therapy
Anticipated Benefits:
• improved diagnosis of disease 
 earlier detection of genetic predispositions to disease 
 rational drug design 
 gene therapy and control systems for drugs 
 personalized, custom drugs 

## ELSI: Ethical, Legal, and Social Issues
• Privacy and confidentiality of genetic information. 
• Fairness in the use of genetic information by insurers, employers, courts, schools, adoption agencies, and the military, among others. 
• Psychological impact, stigmatization, and discrimination due to an individual’s genetic differences. 
• Reproductive issues including adequate and informed consent and use of genetic information in reproductive decision making. 
• Clinical issues including the education of doctors and other health-service providers, people identified with genetic conditions, and the general public about capabilities, limitations, and social risks; and implementation of standards and quality‑control measures.

• Uncertainties associated with gene tests for susceptibilities and complex conditions (e.g., heart disease, diabetes, and Alzheimer’s disease). 
• Fairness in access to advanced genomic technologies. 
• Conceptual and philosophical implications regarding human responsibility, free will vs genetic determinism, and concepts of health and disease. 
• Health and environmental issues concerning genetically modified (GM) foods and microbes. 
• Commercialization of products including property rights (patents, copyrights, and trade secrets) and accessibility of data and materials. 


## Beyond the HGP: What’s Next?
HAP MAP
$100 M public-private effort to create the next generation map of the human genome.
Goal is to understand the .1% (100-99.9) difference that makes humans different from each other.
Human genome is thought to contain 10 million SNPs.
Expected to take 3 years to complete.
DNA taken from blood samples from researchers in Nigeria, Japan, China, and US (northern, western europe ancestory).
Use 200-400 samples in widely distributed geographic regions.

SYSTEMS BIOLOGY
Explore life at the ultimate level: that of the whole organism instead of individual components such as single genes or proteins.  
This new “systems biology” approach combines DNA sequences with advanced technologies to study how PROTEINS – the products of genes—carry out all the activities of a living cell. 


## Genomes to Life: A DOE Systems Biology Program
Goals
• identify the protein machines that carry out critical life functions• characterize the gene regulatory networks that control these machines• characterize the functional repertoire of complex microbial communities in their natural environments• develop the computational capabilities to integrate and understand these data and begin to model complex biological systems


## GTL Applications in Energy Security and Global Climate Change


## HapMap
An NIH program to chart genetic variation within the human genome

• Begun in 2002, the project is a 3-year effort to construct a map of the patterns of SNPs (single nucleotide polymorphisms) that occur across populations in Africa, Asia, and the United States.• Consortium of researchers from six countries
• Researchers hope that dramatically decreasing the number of individual SNPs to be scanned will provide a shortcut for identifying the DNA regions associated with common complex diseases
• Map may also be useful in understanding how genetic variation contributes to responses in environmental factors

# Biological Databases


## Databases
Database– “a computerized archive used to store and organize data in such a way that information can be retrieved easily”
(J. Xiong, Essential Bioinformatics, p. 10)

The generation of vast amounts of sequence data has necessitated the development of numerous biological databases.

Purposes of biological databases:
 Easy data retrieval 
Data is retrieved by “making a query” (querying the database)
 Knowledge discovery
Knowledge discovery refers to identifying connections or commonalities between pieces of information that were not known when the information was entered in the database 	

## Database terminology:
Database terminology:
 Each record in the database is an entry 
 Each entry consists of multiple fields
 Each field holds a value

Example:
	Database:


	Entry:



	Fields:



	Values:

## Types of databases
### Flat files 

A long text file in which entries are separated by a special character (such as | ); fields within an entry are separated by commas or tabs.

Inefficient searching– because entire file must be searched to find a particular piece of data.

Example of a flat file database:

Name, States, Course number, Course name|John Smith, Texas, 
Biol 689, Bioinformatics|Jane Doe, Kansas, Bich 441, Biochemistry|
William Brown, Illinois, Chem 289, Organic Chemistry|Jennifer Taylor,
New York, Hort 201, Horticulture|Howard Douglas, Texas, Math 172,Calculus


### Relational databases
Consist of a set of tables, called relations, that store the data.

Columns in a relation represent fields for all entries; rows represent values for a given entry.

Columns/fields are indexed according to an attribute (see example…).

Easy execution of queries and efficient searching are possible.  However, the tables do not describe complex hierarchical relationships between data items.


Consider the query:  
What are the names of courses that students from Texas are taking?
The tables are linked by common fields which facilitates finding of information.  Therefore, it is not necessary to read the entire database to find the information (in contrast to querying a flat file database).

Look up “State” in Table A    Students 1 and 5
Look up “Student #” in Table B    Biol 689 and Math 172
Look up “Course name” in Table C    Bioinformatics and Calculus

### Object-oriented databases 

Data is stored as objects.  

An object is a unit that combines data and mathematical routines that act on the data.  Objects are linked by pointers that define relationships between them.

Object-oriented databases allow data to be structured according to complex hierarchical relationships (in contrast to relational DB).  However, they lack the rigorous mathematical foundation of relational DB.

Example on next slide:

There are 3 objects in this example…
Their interrelationships are indicated by pointers (all pointers not shown)…
Query: What are the names of courses that students from Texas are taking?
Begin at the state object and follow the pointers to answer the query.



## NCBI Databases and Services

GenBank primary sequence database
   
Free public access to biomedical literature
PubMed free Medline (3 million searches per day)
PubMed Central full text online access

Entrez integrated molecular and literature databases

## TYPES OF MOLECULAR DATABASES
Primary Databases
Original submissions by experimentalists
Content controlled by the submitter
Examples: GenBank, Trace, SRA, SNP, GEO

Derivative Databases
Derived from primary data
Content controlled by third party (NCBI)
Examples: NCBI Protein, Refseq, TPA, RefSNP, GEO datasets, UniGene, Homologene, Structure, Conserved Domain


## PRIMARY VS. DERIVATIVE SEQUENCE DATABASES
## Sequence Databases at NCBI
Primary
GenBank: NCBI’s primary sequence database
Trace Archive: reads from capillary sequencers 
Sequence Read Archive: next generation data

Derivative
GenPept (GenBank translations)
Outside Protein (UniProt—Swiss-Prot, PDB) 
NCBI Reference Sequences (RefSeq)


## GENBANK - PRIMARY SEQUENCE DB
Nucleotide only sequence database 

Archival in nature
Historical
Reflective of submitter point of view (subjective)
Redundant

Data
Direct submissions (traditional records)
Batch submissions
FTP accounts (genome data)

Three collaborating databases

GenBank

DNA Database of Japan (DDBJ) 

European Molecular Biology Laboratory (EMBL) Database

## Derivative Sequence Databases
### GenPept: GenBank CDS translations

### REFSEQ: DERIVATIVE SEQUENCE DATABASE
Curated transcripts and proteins

Model transcripts and proteins

Assembled Genomic Regions

Chromosome records
Human genome
microbial
organelle



### Selected RefSeq Accession Numbers

### GenBank to RefSeq

### REFSEQ: DERIVATIVE SEQUENCE DATABASE

### Selected RefSeq Accession Numbers

### REFSEQ: DERIVATIVE SEQUENCE DATABASE
Curated transcripts and proteins

Model transcripts and proteins

Assembled Genomic Regions

Chromosome records
Human genome
microbial
organelle



### Selected RefSeq Accession Numbers

### GenBank to RefSeq

### RefSeqs: Annotation Reagents

### RefSeq Benefits
Non-redundancy    

Updates to reflect current sequence data and biology

Data validation 

Format consistency

Distinct accession series 

Stewardship by NCBI staff and collaborators

### Other Derivative Databases
Expressed Sequences

dbSNP

Structure

Gene

and more…

## ENTREZFINDING RELEVANT INFORMATION IN NCBI DATABASES

### ENTREZ: A DISCOVERY SYSTEM

### Global Query: All NCBI Databases

### Traditional Method: The links menu

### The Problem
Rapidly growing databases with complex and changing relationships
Rapidly changing interfaces to match the above

Result
 Many people don’t know: 
Where to begin
Where to click on a Web page
Why it might be useful to click there
### Global NCBI (Entrez) Search
### Global Entrez Search Results
### ENTREZ TIP: START SEARCHES IN GENE
### Precise Results
### MLH1 Gene Record
### MLH1:Links to Sequence
### GENEVIEW: HUMAN MLH1 VARIATIONS 
### ‘TAKE HOME MESSAGE’ ADVANTAGES OF DATA INTEGRATION
More relevant inter-related information in one place

Makes it easier to find additional relevant information related to your initial query

Potentially find information indirectly linked, but relevant to your subject of interest
uncover non-obvious genetic features that explain phenotype or disease

Easier to build a ‘story’ based on multiple pieces of biological evidence

# Pairwise Sequence Alignment

## Reminder:

There are four different nucleotides/bases that compose DNA 
and each has a one-letter symbol:


There are 20 different amino acids that compose proteins 
and each has a one-letter symbol:


## WHAT IS SEQUENCE ALIGNMENT?
Sequence alignment– when sequences (protein or DNA) are compared, position by position, to establish the best correspondence between them
Pairwise sequence alignment– the process of aligning two sequences

Example:  Here two DNA sequences are aligned well:



                   Here they are not:


## WHY IS SEQUENCE ALIGNMENT/COMPARISON USEFUL?

Allows one to determine if two sequence are actually related to each other and draw inferences regarding:
 evolutionary relationship 
 similarity of function
 similarity of structure 
Degree of similarity– reveals the evolutionary relatedness of the sequences 
Differences– reflect changes that have occurred during evolution
Similarity between a new sequence and others that are well characterized– may indicate similar structure and function


## HOW IS THE RELATEDNESS OF TWO SEQUENCES EXPRESSED? 
	
 identity 
 similarity 
 homology

Identity– percentage of identical matches between two aligned sequences.

	Example:
Similarity– percentage of aligned residues that have similar physicochemical properties (and can more readily be substituted for each other).
	Example: 




V and A have similar physicochemical properties; so do K and R.

WHICH AMINO ACIDS HAVE SIMILAR PHYSICOCHEMICAL PROPERTIES?

The following is a review of the amino acids and some basic biochemistry…


### Structure of an Amino Acid:
1.  a carbon
2.  amino group bonded to a carbon
3.  carboxyl group bonded to a carbon
4.  hydrogen bonded to a carbon
5.  “R group”/“side chain” bonded to a carbon; 
     20 different common R groups
     
Structures of the 20 amino acids, grouped by physicochemical properties.

One-letter and three-letter codes for each amino acid are shown.

More information about the side chain properties of the 20 amino acids.

(From Essential Bioinformatics, 
by J. Xiong, p. 174)

Amino acids are joined by amide linkages (shaded yellow) to form proteins.  

Each C-N bond is called a peptide bond.

The amide linkages are shaded in yellow and the side chains (R groups) of the amino acids are boxed in blue.

A short chain of amino acids is called a peptide (usually less than ~100).
A longer chain of amino acids is called a protein.
When an amino acid is part of a peptide or protein, it is called an 
amino acid residue.

This end of the chain is called the
amino terminus, or N-terminus, because there is a free amino group.

This end of the chain is called the
carboxyl terminus, or C-terminus, because there is a free carboxyl group.

Amino acid residues in a protein are numbered beginning at the N-terminus:

The amino acid sequence of a protein is always written starting from the N-terminus.  Therefore, the sequence of this peptide would be SGYAL (not LAYGS).

Similarity– percentage of aligned residues that have similar physicochemical properties (and can more readily be substituted for each other).
	Example: 
Homology– an inference that there is an evolutionary relationship between the sequences (that they are descended from a common ancestor).
  VERY IMPORTANT– either they ARE homologous (are related), 
                                 or they AREN’T homologous (aren’t related).
			(It’s like being pregnant– either you
                                 ARE or you AREN’T!  It’s incorrect to
                                 say two sequences are “somewhat” 
                                 homologous.)

HOW DOES ONE INFER HOMOLOGY OF SEQUENCES?
	Based on percentage of identity/similarity.

BUT… two sequences could be identical just by chance.  

Two unrelated/nonhomologous sequences can be identical just by CHANCE.  

SO… at what percentage identity is it safe to infer homology?
	Any two sequences that fall within the “safe zone” can 	safely be considered homologous.

GOAL of pairwise alignment – find best pairing of two sequences so there is maximum correspondence between residues.

Example:

Two METHODS for doing this:

 Global Alignment 
 Local Alignment


Global Alignment– finds best alignment of two sequences over their entire lengths
	Example:
Most appropriate for two highly similar sequences of about the same length.
Local Alignment– finds regions with the highest similarity between two sequences and aligns these regions without regard to the rest of the sequences 
	Example:
      
Most appropriate for two sequences containing only sections (“domains”/ “motifs”) of similarity; the two sequences can be of very different lengths.







## Algorithms for generating global and local alignments may use one of three methods:

Dot matrix (dot plot) method   
Dynamic programming method 
Word method


## Dot matrix (dot plot) method

PROS of the dot matrix method:
 gives a direct visual statement of the relationship between two 
  sequences
 displays all possible sequence matches

CONS of the dot matrix method:
 software that generates the matrix may not construct a 
  sequence alignment (it is up to the user to link the diagonals 
  by adding gaps)
 lacks statistical rigor in assessing the quality of the alignment 
 restricted to comparing only two sequences


In class you will use the dot matrix method to compare two protein sequences.

## Substitution Matrix or Scoring Matrix


# Database Similarity Searches


## An application of PAIRWISE SEQUENCE ALIGNMENT:
Retrieving sequences from biological databases based on similarity to a sequence of interest.

The basic procedure for doing this:

 Submit the sequence of interest (the“query” sequence)
 It is aligned in a pairwise manner to EVERY sequence in the database
 Based on these pairwise comparisons, all sequences that have similarity to the query are found
 Pairwise alignments between the query and each of these similar sequences are returned as output



## Why is it useful to compare a particular sequence to a database of sequences?

Determine potential function of the query sequence

Determine homologs of the query (evolutionarily 
　　related sequences)


## Unique requirements of database searching:

	1.  sensitivity

	2.  specificity (selectivity)

	3.  speed





## Unique requirements of database searching:
1.  sensitivity– how good a method is at identifying sequences from the database that ARE actually similar to the query 
(Did it miss some of the similar sequences–  is the output incomplete?)

2.  specificity– how good a method is at identifying sequences from the database that are NOT actually similar to the query and excluding them from the output (Did it incorrectly determine that some UNRELATED sequences were similar to the query– does the output have “extra stuff”?)

	1.  sensitivity
	2.  specificity
	3.  speed– the time it takes to get the output from the 		     database search (This is an important issue, given the 	     size of sequence databases)


It is difficult to satisfy all three requirements (increasing one tends to decrease another); must compromise to achieve reasonable balance


## Algorithms for generating pairwise alignments may use one of three methods:
(1) dot matrix method,   (2) dynamic programming method, 
(3) word method 

Dynamic programming is impractical for pairwise alignment during database searching because it is too SLOW:  
 It is computationally intensive (ALL possible alignments are
  scored)
 A pairwise alignment must be done for EVERY sequence in the 
  database

An estimate made ~10 years ago:
Suppose you have a protein query of 100 residues; 
you search a database of 300,000 sequences; 
the search would take 2-3 hours using dynamic programming. 
Need a method with greater speed, that doesn’t sacrifice sensitivity and specificity…


## Dynamic programming is an EXHAUSTIVE algorithm:
 Exhaustive algorithms find the best/exact solution to a  
  problem
 Dynamic programming scores ALL possible alignments to find 
  the BEST score

To solve the speed problem, use a HEURISTIC algorithm:
 Heuristic algorithms find an approximation of the best solution 
  to a problem without exhaustively considering every possible 
  outcome– they do this by taking shortcuts  
 Heuristic algorithms are not guaranteed to find the best or 
  most accurate solution

A heuristic algorithm will only score SOME alignments, rather than all of them, which saves time; it “takes a shortcut” in order to determine which alignments are worth scoring.



## Two commonly used heuristic algorithms for database searching:  BLAST and FASTA
 They are not guaranteed to find optimal alignment or to find 
  sequences that are true homologs
 BUT they are 50-100 times faster than dynamic programming
 They have only a moderate decrease in sensitivity and 
   specificity
 They use a heuristic word method

The heuristic WORD METHOD:
Based on finding short stretches of identical or nearly identical letters (which are called “words”, “k-tuples”, or “ktups”) in two sequences.

	Example:


## The Basics of the Word Method (local alignment method):
 Find word(s) that two sequences have in common and align 
  them
 Extend the alignment by aligning regions of similarity on either 
  side of each word
 Calculate scores of the aligned regions
 Join adjacent high-scoring regions to obtain the final local 
  alignment


## BLAST:  Basic Local Alignment Search Tool
 Developed by Stephen Altschul at NCBI in 1990

 One of the most popular and widely used bioinformatics tools 
  because it can accurately detect similarities between DNA or 
  protein sequences quickly without sacrificing sensitivity

 Uses a heuristic word method to align a query sequence with  
  all sequences in a database (local alignment)

Two versions (which differ slightly):  
	NCBI-BLAST, developed at NCBI:
		More widely used;
		Available online at: http://blast.ncbi.nlm.nih.gov/Blast.cgi
	WU-BLAST, developed at Washington University: 			Developed from the original NCBI version;
		Available online at EMBL-EBI: http://www.ebi.ac.uk/Tools/blast2/




## How does BLAST work?
1. Create a list of ALL words found in the query sequence.  Usually word size (w) is 3 residues for proteins, 11 for DNA.  These words, rather than the full sequence, will be used for searching a sequence database.

	Example query sequence:  ...RLRDQHK... 
	Query words will be (w=3):   RLR, LRD, RDQ, DQH, QHK....

2.  Determine which words will be “matches” for each query word.  
There are a total of 8000 possible 3-letter words (20 x 20 x 20).  For each query word, create a table of the words (out of the 8000) that align with the query word to give a score ≥ a certain threshold (T); usually T = 11 for proteins.  (Choose a scoring matrix to calculate alignment scores; default is BLOSUM62.)
	Example:  use the query word  RDQ
	Align   RDQ  with each of the 8000 words and calculate scores:


## Repeat step 2 for each word in the query sequence.  
Each query word will then have an associated table of “matching” words with scores above the threshold, T.










3. Search each sequence in the database for an exact match to any of the query words OR associated matching words (any database sequences that don’t contain any of the words can be discarded from further consideration).

4.  When a match is found to a database sequence, the word is used to “seed” a possible ungapped alignment between the query sequence and database sequence.


Example of seeding:  
REQ is similar to the word  RDQ  in the query sequence (T ≥ 11). 
REQ occurs in a particular database sequence:
Align these words:





If another word match is found “near” this one, the two are joined to form a longer ungapped region of alignment.  (Earlier versions of BLAST did not require two proximal words in a database sequence.)

5.  The aligned region is extended on either side until the total align-ment score begins to drop due to mismatches.  This aligned region is called a high-scoring segment pair (HSP).



6.  If the HSP’s alignment score is greater than a certain cutoff        value (S), it is kept.  If the HSP’s score is less than this cutoff, this alignment is discarded.









7.  If multiple HSP’s are found for a single database sequence, they may be connected to generate a longer, gapped alignment.  Thus, BLAST produces gapped local alignments.  (Earlier versions of BLAST did not have this step.)

8.  A Smith-Waterman local alignment is generated for the query sequence and each matching database sequence.  The BLAST output shows these alignments.  The matching database sequences are called “hits” to the query sequence.  They are the sequences that are similar (and possibly homologous) to the query.


## Effect of Changing Threshold Values on a Protein BLAST Search
Think about the trend in # of hits to database . . . we will discuss this in class. 

Note that the final results are similar for default threshold and lower threshold of 5 (although T= 5 will be slower).

But some hits are missed with higher threshold of 17.


## But how do we know if an alignment obtained from BLAST is statistically significant?   Can we infer that the two sequences are homologous?  

Maybe two unrelated sequences could be aligned with a score that is just as good…







Calculate a P-value to determine the chances that a score ≥ S could be obtained by aligning two unrelated sequences.  

If the chances are low (small P-value), then it is “safe” to conclude that this alignment is not due to chance and to infer that the sequences are homologous.

For the comparison of a query sequence to a database of random sequences of uniform length, the alignment scores follow the Extreme Value Distribution:

The P-value of a given alignment score indicates the probability that the alignment is due to chance (the smaller the P-value, the less likely the alignment is due to chance).

	P(x ≥ S) = 1 – exp [– Kmne-lS ]
	m and n are the lengths of the two sequences being compared; 
	K and l are constants that depend on the scoring matrix used. 
	
In the context of a database search the P-value is:

	P(x ≥ S) = 1 – exp [– Km’n’e-lS ]

	n’ is the “effective” length of the query sequence
		(actual length, n, minus average length of an 			alignment between two random sequences of 			lengths m and n)
	m’ is the “effective” length of entire database (in residues)
		(actual length, m, minus average length of an 			alignment between two random sequences of   			lengths m and n)
	K and l are constants that depend on scoring matrix used 
	

## BLAST Search Statistics
The following tables are part of the output from a real BLAST search.  Note the items that are marked.




## The SIZE of the DATABASE is important:
The larger the database being searched, the more unrelated sequences there are, and the greater the chances that you will find a high-scoring match between the query and an unrelated sequence.

For a given database size, we can calculate the number of high-scoring matches we expect to observe between the query and unrelated sequences.  That number is called the E-value (expected value).

E = Km’n’e-lS      or        E = pD  (when p < 0.1)
       D = number of sequences in the database (database “size”)
       p = probability, according to Extreme Value Distribution,   
             of obtaining an alignment score ≥ S by chance
      m’ = effective length of the database in residues (another 
              measure of database size)
     
A p-value is a way of representing the significance of an alignment.  An E-value is simply another way of representing the significance of that alignment.

## HOW TO INTERPRET AN E-VALUE:

The E-value is the number of HSP’s with an alignment   score ≥ S that are expected to occur by chance when searching a database of D sequences.

Suppose we found an HSP with score = 20 when searching a certain database:
 If E = 4, then we expect to find four HSP’s by chance that 
  have scores ≥ 20 when searching this database using the 
  same parameters.
 If E = 0.01, then we expect to find 0.01 HSP’s by chance 
  that have scores ≥ 20 when searching this database using  
  the same parameters.    

E-values are shown on BLAST output using a rather strange notation.  For example, an E-value may be shown as:  1e-5
	The notation “1e-5”  means  1 X 10-5


Interpreting E-values in Terms of Sequence Homology

E-values                            Interpretation                                                            .
E-value < 1e-50		high confidence the match is NOT due to chance        				(“safe” to infer homology)
E-value    0.01  to 1e-50 	“safe” to infer homology
E-value    10 to 0.01 	match is not significant, but possible distant homologs
E-value > 10		sequences may be related by chance

(the smaller the E-value, the less likely the alignment is due to chance)

E-values are useful for evaluating the significance of an alignment resulting from a database search.  

HOWEVER, E-values obtained when searching one database cannot be compared to those obtained when searching another database or when using a different scoring matrix and gap penalties.



BECAUSE the E-value will increase as the size of the database increases.
E = pD 	



## Is it valid to compare the scores of two alignments from different BLAST searches to determine which alignment is “better”?
 The raw score of an alignment depends on the scoring matrix 
  and gap penalties used.  
 BLAST output shows normalized scores in addition to raw 
  scores; these normalized scores are independent of the 
  scoring matrix.
 
Calculation of a normalized score (S’):
          	S’ = (lS - lnK) / ln2

	S = raw alignment score 
	l = constant that depends on scoring matrix
	K = constant that depends on scoring matrix

S’ accounts for the scoring system that was used because it incorporates l and K.

Example:

 query_sequence  Y C D A
        matches  +   +
   database_seq  F M E G
BLOSUM62 scores: 3-1 2 0

(Scores in BLOSUM matrices are in “half bits.”) 
(“bits” = logarithms to the base 2)
(Scores in PAM matrices are base 10)
 
Raw score:     3 – 1 + 2 + 0  =  4 half bits  =  2 bits


Normalized score:    (Using l = 0.32 and K = 0.136)

	[(0.32 x 2 bits) – ln(0.136)] / ln2  =  3.8 bits


## Low Complexity Regions (LCRs):

Regions that contain highly repetitive residues, and therefore,  have low information content.  LCRs may be:
 short repeating segments
 segments that contain an overrepresentation of a small   
  number of residues

LCRs may account for 15% of total protein sequences in public databases.

LCRs in the query sequence can lead to spurious hits and artificially high alignment scores with unrelated sequences.

## Two options for filtering/masking LCRs in the query sequence during BLAST:

Filter (Low complexity regions): 	
 Characters in LCRs are ignored by BLAST and not used in 
  the alignment process
 In the output, LCR regions of the query are replaced with  
  lower-case characters or an ambiguous character (X for  
  proteins, N for DNA)

Mask (Mask for lookup table only):
 Characters in LCRs are ignored in constructing the lookup 
  table of words, but are used in word extension and  
  optimization of alignments

(Of course it is possible that authentic matches may be missed when filtering is applied)

## There are more than seven versions of BLAST available at NCBI:
      1. BLASTP
      2. BLASTN and megablast
      3. BLASTX
      4. TBLASTN
      5. TBLASTX
      6. bl2seq (pairwise alignment of two sequences)
      7. PSI-BLAST

The first five versions are described on one of the following slides.  PSI-BLAST will be described later in the course.

Before the description of the first five versions of BLAST, here is a review of reading frames…


## Recall that a strand of mRNA has three reading frames:



## The six potential proteins encoded by the six reading frames are shown below.  Each amino acid is “lined up” directly below the first nucleotide of the codon encoding it.  A few are color-coded so you can see how this works.  Compare this to the previous slide.


## FASTA:  FAST-All
 Developed by David Lipman and William Pearson in 1988
 The first widely used program for rapid database searching
 Uses a heuristic word method to create local alignments of a 
  query sequence with database sequences
 Begins by looking for exact matches of words in the two 
  sequences (ktup = 1 or 2 for protein, and 4-6 for DNA)
 
 Available online at University of Virginia (W. Pearson):
       http://fasta.bioch.virginia.edu/fasta_www2/fasta_list2.shtml
 Available online at EMBL-EBI:  
       http://www.ebi.ac.uk/Tools/fasta/index.html



## Comparison of BLAST and FASTA:
Several published studies have performed analyses to determine which algorithm performs better in various scenarios.

 BLAST is faster
 FASTA generally produces a better final alignment
 FASTA is more likely to find distantly related sequences
 Performance of the two methods is similar for highly similar 
  sequences


 Both methods are appropriate for rapid initial searches


## Database Searching Using an Exhaustive Algorithm:

In practice, BLAST and FASTA are usually successful in finding sequences in a database that are related to a query.

BUT they are not guaranteed to find all related sequences in a database or to produce the best alignment because they are heuristic methods.

The Smith-Waterman dynamic programming algorithm provides the most reliable method for finding related sequences in a database search.

Parallel computing has made it possible to use the Smith-Waterman algorithm for database searching in a reasonable timeframe (but not for routine use).

SSEARCH at the University of Virginia is based on S-W algorithm:
http://fasta.bioch.virginia.edu/fasta_www2/fasta_list2.shtml

# Multiple Sequence Alignment


## What is multiple sequence alignment (MSA)?

	To align 3 or more related sequences to achieve 	optimal matching of the sequences.





## How do we find related sequences that are appropriate to align in a MSA?  
	By database similarity searching.  



## Why is multiple sequence alignment important?
 Reveals more biological information than many pairwise  
  alignments:
 Allows identification of sequence motifs in
  the whole protein family.
 Conserved and functionally critical amino
  acid residues can be identified.

 Provides the basis for the most sensitive sequence database 
  searching algorithm– PSI-BLAST– for detecting distantly 
  related homologs.

 It is an essential prerequisite for phylogenetic analysis (which 
  is the inference of evolutionary relationships).

 It is an essential prerequisite for prediction of protein 
  structure.

## Practical uses of multiple sequence alignment:
Predict the function of a newly sequenced protein based on 
  similarity to other members of a family. (Most proteins have 
  been identified by sequencing of genomic DNA or cDNA; 
  functions are assigned to these proteins based on homology, 
  rather than results of biochemical or cell biological assays.)

 Predict the structure of a protein based on similarities to other 
  members of a family.

 Find discrepancies in sequences of cDNA clones.

 Design degenerate PCR primers.

 Identify the consensus sequence for gene regulatory regions.

## The Best Way to Compare Two Proteins

Comparing protein STRUCTURES allows us to determine which residues are in similar positions in 3D space and, hence, are likely to perform similar FUNCTIONAL roles:







We can then generate a SEQUENCE alignment by comparing STRUCTURES.  The extra information from 3D structures allows for a more reliable alignment of residues that are functionally equivalent:
 
 BUT– only a small fraction of proteins have known structures, so a sequence alignment based on structures usually isn’t possible.  Alignment methods must then rely solely on comparison of SEQUENCES.

	(A sequence alignment generated by comparing STRUCTURES is 	the “gold standard” against which sequence alignment algorithms 	are judged.)

A sequence alignment based on STRUCTURES is the most important type of alignment for predicting FUNCTION.

HOWEVER, this type of alignment does not necessarily correspond to the evolutionary alignment implied by divergence from a common ancestor protein. (More info when we cover phylogenetic analysis.)


## A quick review of dynamic programming for pairwise sequence comparison.
Aligning two sequences of 5 residues each using dynamic programming:

Each cell in the matrix contains a score for two aligned residues, one from each sequence.

52 comparisons are made (excluding gaps), so there are 52 cells (25) in the matrix.

The pink arrow shows how one obtains the best alignment by tracing back from the final cell in the matrix.



## The dynamic programming algorithm can be used for multiple sequence alignment.
Aligning three sequences of 5 residues each using dynamic programming:

Each cell/cube in the matrix contains a score for three aligned residues, one from each sequence.

53 comparisons are made (excluding gaps), so there are 53 cells (125) in the matrix.  

The pink arrow shows how one obtains the best alignment by tracing back from the final cell in the matrix.
Aligning N sequences would require an N-dimensional matrix and 5N comparisons.


## How are scores calculated for positions in the matrix?
Sum of pairs method– the value in a particular matrix cell is the sum of the scores of every possible pair of residues at that position. (This is the simplest method of scoring.)  
                                  Example:


## Full dynamic programming is not practical for multiple sequence alignment.

Suppose we want to align 10 sequences, each of length 300 residues:
	need a 10-dimensional matrix with 300 cells in each dimension;  
	30010 comparisons will be made (which is 5.9 X 1024).

Computation time and memory space required increase exponentially with the number of sequences.

MSA by Carrillo & Lipman (1988) is a multiple sequence alignment program that uses the dynamic programming algorithm.  However, it does not calculate scores for all cells in the matrix– uses a shortcut to determine which cells are worth considering.  

It can optimally align 5-7 protein sequences of reasonable length (200-300 residues).

## Divide-and-Conquer Multiple Sequence Alignment (DCA) 
is a program for producing fast, high-quality multiple sequence alignments; it uses a semi-exhaustive algorithm.  

Available at:   http://bibiserv.techfak.uni-bielefeld.de/dca/


## Heuristic algorithms speed up the alignment process by taking shortcuts to limit the space within the matrix within which optimal alignments are likely to be found:
Example:  A heuristic algorithm may determine that optimal alignments are likely to be found only in the pink region.  Therefore, only these cells in the matrix are filled in.  This saves time.

Heuristic algorithms are not guaranteed to find the mathematically optimal alignment for a set of sequences.

HOWEVER, the mathematically optimal alignment rarely makes more biological sense than alignments produced by good heuristic methods!

## Categories of Heuristic Algorithms for Multiple Sequence Alignment:

	1.  Progressive alignment methods

	2.  Iterative alignment methods


## Progressive Alignment Methods 

 Most are based on the progressive 　　　　alignment algorithm published by Da-Fei Feng &  Russell Doolittle in 1987.

 How they work:  first calculate a pairwise alignment for the two  most closely related sequences and progressively add more sequences to the alignment.

　　（Left figure shows the idea)


## Steps in the Feng-Doolittle Progressive Alignment Method 
(Other progressive alignment algorithms differ slightly in the details of these steps.)

1.  Perform pairwise alignments between ALL possible pairs of sequences.  Use Needleman-Wunsch global dynamic programming algorithm.  Calculate a similarity score for each pairwise alignment.
2.  Use the similarity scores to calculate evolutionary distances; carry out a cluster analysis using these distances to construct a “guide tree.”  Some methods use neighbor-joining method to construct the tree; others use unweighted pair group method of arithmetic averages (UPGMA). (More on construction of trees later.)  The guide tree will be used to determine the order in which the sequences will be progressively aligned.

The branching order of the tree reflects the relationships between sequences in terms of similarity; the branch lengths are proportional to evolutionary distance.  

3.  Select the two most closely related sequences from the guide tree and create a pairwise alignment.  








4.  Align the next most similar sequence to the existing pairwise alignment.  The new sequence is added by aligning it pairwise to each sequence in the group in turn.  The highest scoring pairwise alignment determines how the new sequence will be aligned to the group.





(A Note on Scoring:  Each score from pairwise comparison of two residues may be multiplied by a factor based on the evolutionary relationships represented in the guide tree.  Thus, the final sum-of-pairs score will be “weighted” so that more distantly related sequences have a greater contribution to the score.)

5.  Align the next most similar sequence to the existing multiple sequence alignment.  This is done in the same manner described in step 4.









6.  Repeat step 5 until all sequences have been added to the alignment and a full multiple sequence alignment is obtained.

## CLUSTALW 

 Probably the most widely used multiple sequence alignment 
  program.

 Performs global multiple sequence alignment using the 
  progressive method (neighbor-joining method for construction 
  of guide tree).

 CLUSTALW is a newer and better version (1994) of the 
  original CLUSTAL (1988).  (Presumably, the name comes 
  from the fact that building a guide tree is a type of “cluster” 
  analysis.)

 Available online at EMBL-EBI: 
  http://www.ebi.ac.uk/Tools/clustalw2/index.html

 CLUSTALX provides a window-based user interface for 
  CLUSTALW.  Available for download from:
  ftp://ftp-igbmc.u-strasbg.fr/pub/ClustalX/


## Important features of CLUSTALW:

 Does not rely on a single scoring matrix:
 Applies different matrices depending on degree of similarity between  
  sequences.
 For example, BLOSUM80 for initially aligned closely related sequences;
  BLOSUM50 later when more divergent sequences are added to the 
  alignment.

 Weighting scheme used in scoring alignments: 
 Indicated by “W” in the name. 
 More distantly related sequences have a greater contribution; highly similar
  sequences don’t dominate the alignment.

 Does not rely on a single set of gap penalties:
 When sequences of structurally related proteins are aligned, gaps occur 
  preferentially in loop regions between elements of secondary structure.  
  Gaps are also more likely to occur next to some amino acids than others. 
 CLUSTALW uses this information to try to place gaps between conserved 
  domains, rather than within these domains (conserved domains are likely 
  to represent elements of secondary structure).  The program does this by 
  changing the initial gap penalties as more sequences are added to the 
  alignment– e.g., penalties are decreased within stretches of certain amino   
  acids that are more likely to be part of a loop region. 


## Problems with progressive alignment methods:

 Errors made early on in the initial alignments will be propagated as new 
  sequences are added to the alignment: 
 Gaps introduced in the initial alignments remain– “once a gap, always a 
  gap.” (Gaps remain because it is assumed that the two most closely related 
  sequences, that are initially aligned, should be weighted most heavily in 
  introducing gaps.)

 Difficult to choose a scoring matrix and gap penalties that are appropriate 
  for the entire set of sequences:
 Some sequences in the set may be very closely related while others 
  are distantly related.
 CLUSTALW addresses this problem because it does use multiple scoring  
  matrices and changes the gap penalties.

 Only suitable for sequences of similar lengths since it is a global alignment 
  method. (Truncating the sequences will sometimes solve this problem– you will 
  see an example of this on the next homework assignment.)

 Slow–   it’s time-consuming to generate the first all-against-all pairwise
  alignments that are necessary for generating the guide tree:
 N (N – 1) / 2  alignments must be generated.
 Example:  for 100 sequences, 4950 pairwise alignments must be made.


##                                           T-Coffee:  
Tree-based Consistency Objective Function For alignmEnt Evaluation

T-Coffee addresses some of the shortcomings of CLUSTALW and other progressive alignment algorithms:
	1.  Performs global and local pairwise alignments for all possible 
                  pairs of sequences.
	2.  The consistency of the global and local alignments is evaluated, 
                  and the pairwise alignments are refined.
	3.  A guide tree is derived from the pairwise alignments.
	4.  A full multiple sequence alignment is generated progressively 
                  based on the guide tree.

 Since T-Coffee optimizes the initial alignments, it minimizes the initial 
  alignment errors which will be propagated to the final alignment.

 T-Coffee shown to outperform CLUSTALW for moderately divergent 
  sequences, but it is much slower.

http://www.tcoffee.org/Projects_home_page/t_coffee_home_page.html

http://tcoffee.vital-it.ch/cgi-bin/Tcoffee/tcoffee_cgi/index.cgi


## Categories of Heuristic Algorithms for 
                  Multiple Sequence Alignment:

	    1.  Progressive alignment methods

	    2.  Iterative alignment methods


Iterative alignment methods attempt to correct a problem   of progressive methods:  
	Errors in the initial alignments of the most closely   	related sequences are propagated to the final multiple 	sequence alignment.



## Iterative Alignment Methods


## There are many programs available for multiple sequence alignment.

 All have their strengths and weaknesses; choice of a program 
  will depend on various factors that are important to the user:
 Speed
 Ease of use
 Characteristics of sequences being aligned (similar vs.  
  different lengths; closely related vs. divergent)

 Best to try several methods on the same set of sequences.

 CLUSTALW is popular because it is easy to use and quickly 
  provides an adequate alignment of a large number of closely 
  related sequences.

 Another progressive method:  PRALINE

 Two iterative methods: DIALIGN2, PRRN


## One application of multiple sequence alignment (MSA):  
Using a multiple sequence alignment to identify related sequences / family members.  

 Why can a MSA be used to find related sequences? 
	Embedded within a multiple sequence alignment is intrinsic 	sequence information that represents the common characteristics  	of that particular collection of sequences.

 One very simple way to use a MSA to find related sequences:
	Convert the multiple sequence alignment to a single “consensus” 	sequence, and use the consensus sequence to search databases. 
Note that the consensus sequence isn’t identical to any of the sequences from which it was derived, but it contains information derived from all of them.

BUT:  a consensus sequence doesn’t capture very much information about the sequences from which it was derived, so it wouldn’t work well to identify related sequences in a database.

THE SOLUTION:  a position-specific scoring matrix (PSSM) contains much more information than a consensus sequence.

 A PSSM is a table/matrix that contains probability information for the 
  residues at each position in an ungapped multiple sequence alignment.    
  	(Tells us the probability of finding ‘A’ at the first position, AND the 
  	probability of finding ‘L’ at first position, etc.)
 A PSSM can be used to search sequence databases.

## An Example of Construction of PSSM


## Interpreting a PSSM

Each value in the PSSM is the ratio of the observed counts of that amino acid at a given position in the multiple sequence alignment, divided by the expected count of that amino acid at that position in the alignment.  This value is then converted to a log scale (usually base 2).

The values in the PSSM reflect the probability of any given amino acid occurring at each position in the alignment, and the effect of a conservative or nonconservative substitution at each position in the alignment.


The residue ‘G’ occurs most frequently at position 1 in the alignment, so a ‘G’ is shown in position 1 of the consensus sequence.  

The first row of the PSSM corresponds to position 1 of the alignment.  Notice that the amino acid ‘G’ is given the highest number in this row:  31.  This reflects the fact that G is the residue most likely to occur in position 1.

The 2nd row of the PSSM corresponds to position 2 in the alignment.  The amino acid ‘P’ is given the highest number in this row, reflecting the fact that P is the residue most likely to occur in position 2.  Etc.
Position 8 in the alignment is always ‘T’. 
Position 10 in the alignment is always ‘G’.  
The high values in the PSSM (150) reflect this.

Position 9 is almost always ‘P’.  The high value in the PSSM (89) reflects this, but the score is not as high as it would have been if ‘P’ always occurred at this position.

Amino acids with negative values are not likely to be found at that position in the multiple sequence alignment.


## The information content in a PSSM:

A formal method called information theory can be used to describe the amount of information in each row in a PSSM. 

Consider the multiple sequence alignment here:

Columns 8 and 10 contain more information 
than any others because the amino acid at that 
position is conserved in each case.  Column 9
also contains a lot of information, but not quite
as much as 8 and 10.

Column 1 is highly variable, so it contains less
information than the others.


## Suppose we want to know which amino acid belongs at a particular position in a multiple sequence alignment of a family of related proteins.

The amount of “uncertainty” in the identity of the amino acid at that position is given by:

    –log2 (probability of a certain amino acid) 

    –log2 (1 / 20) = 4.32 bits

An uncertainty of 4.32 bits means we have no information at all regarding the likelihood of one amino acid versus another at a given location. Suppose we aligned 20 different sequences and found that every amino acid occurred once at a given position in the alignment.  The uncertainty at that position would be 4.32 bits (the maximum value).

The data in a PSSM provide information that reduces this uncertainty to values less than 4.32.  If only ‘T’ occurs at a given position when we align different sequences, the uncertainty at that position is reduced to zero bits.


## The higher the information content of a PSSM (the lower the uncertainty), the more useful the PSSM.

The information content (amount of uncertainty) in a PSSM can be represented by a graph called a sequence logo (shown below).

Each column in the logo represents a column in the multiple sequence alignment and in the PSSM.  The amino acids shown in a given column of the logo are those that appear in that column in the alignment.

## Interpreting a Sequence Logo

The total height of each column gives the decrease in uncertainty provided by the information content at that position in the PSSM.  Taller columns contain the most information because the uncertainty has been reduced the most.  The height of a column also reflects the diversity of amino acids that can occur at that position–    taller columns for conserved positions.

The height of each amino acid within a given column is proportional to its frequency of occurrence at that position in the PSSM.  They are stacked in increasing order of abundance.  


## How can profiles and PSSMs be used?

 To determine if a sequence of interest contains the sequence 
  motif represented by the PSSM.











 To search a sequence database to find new members of the 
  family represented by the PSSM.  (Described on subsequent 
  slides)



## Determining if a sequence of interest contains the sequence motif represented by the PSSM: 
 we can determine how well any sequence of the same length as the PSSM “fits” the PSSM.

How is this done?
Example:  Is the sequence ‘GGDIVVGTPG’ another example of the    
sequence motif represented by this PSSM?
 Score this new sequence using the PSSM (follow red #s in PSSM):
	      31 + 13 + 29 + 63 + 50 + 58 + 44 + 150 + 89 + 150 = 677
 Calculate the probability of the motif occurring in the sequence:  
                   2677 = 6.27 X 10203
	      The sequence is 6.27 X 10203  times more likely to fit the motif 
                   because it is related to the other sequences, than to fit by chance.


## Determining if a sequence of interest contains the sequence motif represented by the PSSM:

Suppose we want to determine if a new protein contains the sequence motif, but we don’t know the location of the motif in the new protein sequence.  

Use the PSSM to “scan” the new protein’s sequence:

The highest scoring location is the most likely position of the motif in the sequence.  The significance of the score can be evaluated by calculating the value of  2score  (see previous slide).


## To search a sequence database to find new members of the family represented by the PSSM:

 The PSSM is used to scan each sequence in the database using the
  method just described:










 Advantage of searching a database with a PSSM rather than a single 
  member of the family:  more sensitive– will be able to identify additional 
  family members that might be missed if using a single sequence to search 
  the database.

 PSI-BLAST is one program that does this.



## PSI-BLAST:  Position-Specific-Iterated BLAST  (y-BLAST)

Steps of the algorithm:

1.  Query a protein database using a single protein sequence (same as a BLASTP search).

2.  Any related sequences found in the search (those with E-values below a cutoff / threshold) are aligned with the initial query sequence to create a multiple sequence alignment, and a profile is created from this alignment.

3.  The profile is used to again search the database–  so the search has been expanded to include sequences that match the variations found in the multiple sequence alignment at each sequence position.

4.  Any newly discovered sequences (hits from the search) that are similar to those used to create the profile are then added to the multiple sequence alignment and an updated/refined profile is created.

5.  The refined profile is used to search the database again to find more distantly related sequences.  Steps 4 and 5 are repeated until no new sequences are found, or until the user chooses to stop the iterations (usually it is best to stop after a few iterations).


## PSI-BLAST:  Position-Specific-Iterated BLAST

PROS:
 Easy to use.

 Fast.

CONS:
 Determining the significance of the alignments found– 
       The sequences found may be distantly related family  
       members, or matches may just be due to chance.

 Newly found sequences that match the query influence the 
  finding of more sequences like themselves– 
       There is no guarantee that subsequently discovered 
       sequences are in the same family.


## The usefulness of a PSSM or profile depends on the sequences from which it was derived:

If the set of sequences is small, the values in the PSSM / profile may not adequately represent all sequences in the family.

# Protein Motifs and Domains



## Protein motifs and domains are consensus sequence patterns.

Motif– a short conserved sequence pattern; can be just a few amino acid residues, up to ~20.
Examples:  

Domain– a longer conserved sequence pattern which adopts a particular three-dimensional structure and is an independent functional and structural unit;  typically 40-700 residues.
Example of a two-domain protein:

This protein (troponin C) is composed
of a single amino acid chain, but
each half of the chain forms an
independent structural and functional
unit– a domain.


## More examples of protein domains
This protein (hemocyanin) has two distinct domains (blue and green) which are connected by a short linker (red). 
The amino acid chain of hemocyanin can 
be represented like this:

This enzyme (laccase) has three distinct domains (each colored differently). 


## Domains may contain motifs.  Hemocyanin as an example:

The “green” domain of hemocyanin contains this copper-binding motif:

A group of proteins that share a domain in common constitute a FAMILY.    Family members are evolutionarily related (homologous) and their domains have sequence similarity.

Family members can share a domain in common in a number of ways:

## NOTE:  Many short motifs are NOT specific to a particular protein family.  Thus, their occurrence does not indicate homology.

Example:  
protein kinase C phosphorylation site has this 3-residue motif:


(S or T, followed by any residue, followed by R or K)



This is a common motif that occurs in many unrelated proteins.


## Motifs and domains are FUNCTIONAL elements of proteins.

Some examples of biochemical functions of domains:
 An enzyme’s catalytic domain has the function of catalyzing 
  the conversion of a reactant into a product.
 A structural protein domain has the function of influencing the 
  shape of a cell.
 The binding domain of a transport protein has the function of 
  carrying a ligand from one location to another.

Some examples of the functions of motifs:
 The Y’s of this tyrosine motif have the function of interacting 
  with specific residues of a protein to stabilize its structure.


 The H’s and C’s of this zinc finger motif have the function of 
  binding zinc ions.


## How are motifs and domains identified in protein families?

By aligning family members in a global multiple sequence alignment.  
Motifs and/or domains can then be identified as conserved regions of the alignment.  Sometimes it is easy to align the sequences, and these conserved regions are obvious and can be identified “by eye.”  

At the right is an example of a multiple sequence alignment of a family of proteins. A conserved copper-binding motif is known to exist in these proteins.  Examine the alignment carefully– can you identify the region containing the motif?  




The copper-binding motif is within the red box.  It is located within a conserved section of sequence which is marked with a yellow box (note the “ * : . ” symbols below the alignment which indicate conserved residues).

Sometimes (as in this example) it is easy to align family members and identify conserved regions that are likely to be important to the function of the protein.

However, for distantly related sequences, it may be very difficult to even align the sequences properly, let alone detect conserved sequence patterns.  These situations require the use of sensitive statistical methods.



## Why is it useful to identify motifs and domains in families of proteins?

 To identify the functionally important residues and patterns in  
  a given domain.

 To predict the function of a new protein by comparing its 
  sequence to the sequences of domains with known  
  functions.


## How are motifs and domains in protein families represented?

1.  Regular expressions/patterns

A multiple sequence alignment is converted to a consensus sequence called a regular expression or pattern.  Example:


## Interpreting regular expressions:

	Example:


	Interpretation:
		First residue of the pattern is E; 
		followed by any 2 residues; 
		followed by F, or H, or M;
		followed by any 4 residues;
		followed by any residue except P;
		followed by L.

Limitations of regular expressions:
They do not take into account sequence probability information about the multiple sequence alignment.  For instance, in the above example, we don’t know how often F, H, and M each occur at the 4th position in this motif.  H may be much more common than F or M, but we have no way of knowing this from the regular expression.



## How are motifs and domains in protein families represented?
1.  Regular expressions/patterns
2.  Statistical models:  
     PSSMs, profiles, and profile hidden Markov models.

Recall that position-specific scoring matrices (PSSMs) and profiles are numerical representations of a multiple sequence alignment that contain information about the probability of observing a specific residue at a given location in the alignment.

See Powerpoint notes from “Multiple Sequence Alignment” to review PSSMs and profiles.  

Profile hidden Markov models are explained next…



## Profile hidden Markov models (HMMs) are similar to PSSMs and profiles because they describe the likelihood that a specific amino acid residue occurs at a given position in an alignment.

        Consider this multiple sequence
                  alignment of a short motif:

If we were to construct a PSSM for this sequence alignment, we would set up a 20X5 matrix– 5 matrix rows (one for each column in the alignment), and 20 matrix columns for the 20 possible amino acids.  Each position in the matrix would have a number indicating the probability of finding a particular amino acid at that column in the alignment.  (See Multiple Sequence Alignment Powerpoint notes for examples of PSSMs.)

A profile HMM contains the same type of probability information for various amino acids at all positions in the alignment, but this information is presented in a specific type of diagram, rather than in a matrix.  The next slide shows one of these diagrams.

## To keep things simple, assume that gaps are not allowed in this alignment.  Below is a diagram representing a profile HMM for this sequence alignment.

Each box represents a position in the alignment and is called a “match state.” 

Each match state contains the probabilities of observing various residues at that position in the alignment– for example, the probability of a T in the second position is 2/5, or 0.4.  These probabilities are called “emission probabilities.”  

Each arrow represents a transition from one match state to the next.  Each transition has an associated probability called a “transition probability.”


## Profile HMMs account for gaps in an alignment:

Below is a generic structure of a profile HMM that includes information about insertions and deletions (gaps) in the multiple sequence alignment from which it was generated.  

The squares represent match states, the diamonds represent insert states, and the circles represent delete states.  

The arrows represent transitions from one state to the next.  (Note the circular arrow on each insert state.  This allows for insertion of more than one residue between match state positions.)


Each match state, insert state, and delete state has an associated set of emission probabilities for the 20 amino acids that are based on the observed frequencies of the amino acids at that position in the alignment.  For example:














Each arrow/transition has an associated transition probability indicating the probability of transitioning to another state.  The sum of the probabilities of transitions leaving each state is one.  


## Here is a profile HMM derived from a sequence alignment of a short motif:
The alignment is color coded to correspond to its profile HMM.  There are three match states, corresponding to the three conserved amino acids in the motif (G,T,W).  
Seq5 has an insert (A) between the first two match states.  Seq3 has a delete in place of the third match state.

	        The path of seq1 through the HMM would be:  		BeginM1M2M3End
	        The path of seq3 through the HMM would be:  		BeginM1M2D3End
	        The path of seq5 through the HMM would be:
		BeginM1I1M2M3End

NOTE:
Profile HMMs are different from regular profiles because they distinguish between inserts and deletes when accounting for gaps in an alignment.

## Construction of a profile HMM:

Constructing a profile HMM from a set of related sequences is called “training” the model.  

The sequences used are the “training set.”  (They do not necessarily have to be aligned prior to constructing the HMM.)  

Usually 50 or more related sequences are needed to train the model, but sometimes as few as 20 sequences will work.

To construct a profile HMM from an alignment, we must assign:
     (1) the length of the model (how many match states)
     (2) the probability parameters (emission and transition probabilities)

(1) Length of the model:
A length of 8 match states is appropriate for the HMM that will represent this alignment.  The 8 match states correspond to the columns indicated by the asterisks.  

A simple rule of thumb is that columns with more than 50% gap characters should be modeled as insert states rather than match states.  Therefore, columns 4 and 5 of the alignment are not included as match states because all sequences except Seq7 have gap characters in these columns.  Instead, Seq7 will have two insert states in a row between match states 3 and 4.
(2) Probability parameters:

The values of the emission and transition probabilities are based on the number of times a particular amino acid or gap appears in a given column.  In the initial phase of training the model, estimates are made for these probabilities.  The model is trained by iteratively refining it and updating the probabilities.  This may take up to 10 rounds.

A major problem is that there may not be very many sequences (family members) in the training set, so some legitimate transitions or emissions may not be represented in the alignment and would receive a zero probability.  Then these transitions and emissions would not be allowed when the HMM was used in the future.  To avoid zero probabilities, pseudocounts are added to the observed frequencies of each amino acid.  The simplest pseudocount method is Laplace’s rule in which one is added to each observed frequency.  

For example, V appears 5 times in column 1.  According to Laplace’s rule: 
     the count for V in column 1 would become 6  (5 real counts + 1 pseudocount); 
     the count for F in column 1 would become 2  (1 real count + 1 pseudocount); 
     the count for I in column 1 would become 2 (1 real count + 1 pseudocount) ; 
     the count for any other residue in column 1 would be 1 (0 counts + 1 pseudocount).




## How do we find motifs and domains that may be present in the sequence of a new protein?

Regular expressions, PSSMs, profiles, and profile HMMs represent motifs and domains found in protein families.  Therefore:

 An individual sequence can be compared to a regular expression, PSSM, 
  profile, or profile HMM to see if the new sequence “fits” the previously   
  characterized domain or motif that is represented.  This process was 
  explained for PSSMs in the “Multiple Sequence Alignment” PPT notes.

 Better yet, an individual sequence can be compared to an entire 
  database of regular expressions, PSSMs, profiles, or profile HMMs to see 
  whether it belongs to any of the previously characterized families.

NOTE:  The statistical models have much more predictive power than regular expressions.  Profile HMMs are especially powerful.  In fact, one of the main purposes of developing profile HMMs is to use them to detect potential membership in a family by obtaining a match of a sequence to the profile HMM.



## Scoring a match of a new sequence to a profile HMM:    
                         new_seq: GTVW

The best path through the model for the new sequence ‘GTVW’ appears to be:
	BeginM1M2I2M3End

The path is highlighted in red below.  To score this path, 
we add the log odds scores for the relevant emission (E)   and transition (T) probabilities:
Score = T1 + EM1:G + T2 + EM2:T + T3 + EI2:V + T4 + EM3:W + T5 

The score is then compared to the score for a random sequence scored against the same profile HMM.  If the 			score of the new sequence is 			significantly better, the new 			sequence can be considered a
 			“match” to the HMM and is likely 
                                           to be another family member.



## Determining if a sequence of interest contains a motif or domain represented by a profile HMM:

Suppose we want to determine if a new protein contains a specific motif or domain, but we don’t know the location of the motif/domain in the new protein sequence.  

We would use the profile HMM to “scan” the new protein’s sequence:
The highest scoring location is the most likely position of the motif/domain in the sequence.  



## Databases of motifs and domains

The following are databases of regular expressions, PSSMs, profiles, and/or profile HMMs derived from alignments of motifs and domains found in protein families.  You can submit a protein sequence to any of these databases in order to determine if the sequence contains one of the motifs or domains represented in the database.

PRINTS (http://www.bioinf.manchester.ac.uk/dbbrowser/PRINTS/PRINTS.html)
Uses PSSMs.  
Breaks a sequence down into small, nonoverlapping motifs; each protein family is said to have a characteristic “fingerprint,” or set of these motifs. 
Beware:  database is small.

BLOCKS (http://blocks.fhcrc.org/blocks/)
Uses PSSMs derived from the most conserved, ungapped regions of alignments.  These ungapped aligned regions are called “blocks.”
Note:  BLOCKS database is no longer being updated.

ProDom (http://prodom.prabi.fr/prodom/current/html/form.php) 
Domain alignments were built using PSI-BLAST.




Pfam (http://pfam.sanger.ac.uk/search) 
Uses profile HMMs.
Two-part database:  Pfam-A (curated) and Pfam-B (automatically generated).

SMART (http://smart.embl-heidelberg.de/)
Uses profile HMMs.  
Alignments of domains checked manually by curators.

InterPro (http://www.ebi.ac.uk/interpro/)
An integrated database designed to unify multiple databases, including PROSITE, Pfam, PRINTS, ProDom, SMART, and others.
Note:  searching InterPro may produce different results than searching the  individual databases that are part of InterPro.

CDART (http://www.ncbi.nlm.nih.gov/Structure/lexington/lexington.cgi?cmd=rps)
Uses profiles.
Includes the SMART and Pfam databases.
Note:  searching CDART may produce different results than searching SMART or Pfam individually.
PROSITE  (http://www.expasy.org/prosite/)
Mainly uses regular expressions, some profiles.
Beware:  some sequence patterns in the database are too short to be specific, and the database is small; results should be treated with caution.

Emotif  (http://motif.stanford.edu/distributions/emotif/)
Uses regular expressions.

Each database has its strengths and weaknesses.  HMM-based methods for finding motifs/domains are the most sensitive, and methods using regular expressions are the least sensitive.  It is always best to search multiple databases when looking for motifs/domains in a new sequence.

If you don’t find any motifs in a sequence when searching a particular database, it could be due to limited coverage of the database.   Try other databases before concluding that the sequence has no known motifs.

Keep in mind that there are many sequences with misannotated motifs/domains in databases.


## Using a profile HMM to find new members of a protein family:

In the “Multiple Sequence Alignment” module you learned that a PSSM or profile can be used to scan a database of individual sequences in order to find other sequences that are members of the family represented by the PSSM/profile.  This is done by scoring every sequence in the database against the PSSM/profile to find any that produce high scores.

A profile HMM can also be used to scan sequence databases in the same manner to find other family members.  



## Identifying motifs and domains using statistical methods:

As mentioned earlier, for distantly related sequences it may be very difficult to align the sequences and detect conserved regions.  Three statistical methods can be used in these cases:
	Expectation maximization algorithm
	Gibbs sampler algorithm
	Profile HMMs

These methods do not rely on a previously produced multiple sequence alignment.  They identify patterns (conserved motifs/domains) in a set of sequences by producing trial alignments and then improving the alignments using statistical methods.

From the final alignment, each of these methods produces a scoring matrix that may be used to search other sequences for the same pattern.

## Expectation Maximization (EM) Algorithm

EM is a two-stage iterative process.  An initial guess is made as to the location and size of a sequence pattern (a motif or domain) in each sequence in a set of related sequences.  These regions are aligned to create a “trial” alignment for the set of sequences.  Using the trial alignment, the residue composition of each column in the alignment is first calculated and used to create a PSSM. 

Step 1.  Expectation
Using the values in the PSSM, the probability of finding the pattern at every possible position in each sequence is calculated. 

Step 2.  Maximization 
The probabilities from step 1 are used to weight the values in the PSSM, essentially providing new information about the likely location of the pattern in each sequence.  The values in the PSSM are updated using these weights.

Steps 1 and 2 are repeated until the values in the PSSM don’t change with continued iterations.



## The Gibbs Sampler Algorithm

Gibbs sampling is an iterative process similar in principle to EM, but the algorithm is different.  At each iteration, one sequence is removed and a trial alignment is built from the remaining sequences.  Like EM, Gibbs sampling searches a set of sequences for the statistically most probable motifs, and can find the optimal width and number of these motifs in each sequence.



Profile HMMs

A profile HMM can be built from a set of unaligned sequences.  An initial guess is made as to the length of the model (number of match states) and the probability parameters.  Then the model is trained by iteratively updating the probability parameters (a variety of algorithms can be used for this process).  



## An Example of EM-algorithm
In the following example, one has a weight matrix of 3 different sequences, without gaps.
Now one counts the number of nucleotides contained in all sequences:
Now one needs to sum up the total: 7+3+12+5 = 27; this gives us a "dividing factor" for each base, or the equivalent probability of each nucleotides.

Now one can "redo" the weight matrix (WM) by dividing it by the total number of sequences (in our case 3):
Next, one divides the entries of the WM at position    with the probability of the base   .
In general one would now multiply the probabilities. In our case one would have zero for every one. Due to this we define 〖𝑙𝑜𝑔〗_10 0□(≔)−10 and take the (base 10) logarithm:
This is our new weight matrix (WM). One is ready to use an example of a promoter sequence to determine its score. To do this, one has to add the numbers found at the position    of the logarithmic WM. For instance, if one takes the AGGCTGATC promoter:0.11 - 0.12 + 0.35 - 10 + 0.73 - 0.12 + 0.41 - 10 + 0.48 = -18.17This is then divided by the number of entries (in our case 9) yielding a score of -2.02.
# Gene Prediction

## The Age of Genomics
There is an ongoing exponential accumulation of genome sequences – likely to continue.

But, it is surprisingly difficult to find and accurately describe all the genes within a given genome sequence.

Thus, the accurate meaningful interpretation of genomes is clearly lagging…

So, there is a tremendous need to develop and improve gene prediction methods


## Why is it hard to find genes?
Genes have parts, like promoters, coding  regions, splice-site signals, etc., that should be useful as landmarks for gene finding.
However, the parts of a gene are generally small, are represented by multiple weakly related alternative forms, and are otherwise difficult to describe or define.
Genomic sequence is fundamentally repetitive due to its use of only 4 characters in short combinations to create the signal landmarks that demarcate genes.  As a foreign language, it is hard for us to “read” and interpret.

As a result, the parts of a gene, and therefore genes in general, are frequently (but not always) hard to recognize. 

In many cases, then, genes are subtle, cryptic structures, and rigorous computational analysis greatly facilitates predictions of the most likely full structure of genes within genomes.

## Easier to find genes in Bacteria/Yeast
In bacteria and yeast, almost all proteins are represented within long Open Reading Frames (ORF’s), so all you have to do is look for an ORF longer than about 250 bp’s, and that’s your gene.

        (This is harder if the gene is short; stop codons appear about every 20 bp’s in random sequence).

## ORF lengths in Yeast

## Introns make things harder…


## Why do introns make it so hard?
Introns add “noise” to the data, so landmarks that are small and fuzzy are even harder to find.
Yeast genome is about 70% protein coding
About 6000 genes, virtually no introns
Human genome is about 1.5% protein coding
About 22,000 genes, average 8.8 introns per gene
mean intron length 4400 bp’s, mean exon length only 165 bp’s
each exon ORF is much closer in size to non-coding ORF’s
splice sites poorly conserved, difficult to recognize


## But knowledge of mRNA/cDNA makes it easier
## Finding Genes the “Old Way”
Demarcating the position and structure of genes responsible for the production of known mRNA’s, cDNA’s, proteins, and/or phenotypes.
Generally done gene by gene one step at a time
RNA/DNA isolation, reverse transcription, PCR, cloning, sequencing, manual alignment, primer extension, etc.
Slow, piece-wise collection of evidence
Simple alignment of cDNA sequence to genomic DNA sequence reveals positions of introns and exons.
A work intensive, deliberate, time consuming process.
But the end results are very valuable as “known” genes that can be used as training sets for computational gene prediction.

## Describing Exons: Signals/Landmarks 


## “Known” Genes provide training “signals”for computerized gene finding

## “Predicting” Genes
Generally, this involves using prior knowledge about the sequence and structure of known genes to identify putative genes within one or more complex genomes.

Applied to large data sets obtained by
Sequencing, sequencing, more sequencing

Uses computerized algorithms
Can be grouped into two general “approaches”

Two major approaches: Intrinsic vs Extrinsic

## Intrinsic vs Extrinsic
Intrinsic methods are also called…
“ab initio” methods (from first principles)
generally suggests no external information was used, but all these methods require external info from models/matrices that provide “signal” info using “signal sensors” and “content” info using “content sensors”  (more on these later)

“template” methods
refers to the combination of  “signal” and “content” sensors to distinguish exon states vs intron states – i.e. providing a generalized model “template” for the recognition of genes


## Intrinsic vs Extrinsic
Extrinsic methods are also called…
“homology” methods
refering to the fact that other complex sequences (cDNA, protein) are used to identify genes or gene parts by homology

“look-up” methods
a more computational term that highlights the fact that local alignments with specific known reference molecules (rather than generalized “signals”) are used to identify genes or gene parts.

## Which is better?
Both have their advantages and disadvantages.  However, relevant homologous sequences are usually in short supply (< 50%), so many potential genes would be missed in large genomes.

For new genomes with lots of novel genes, intrinsic methods provide many more predictions.

New approaches that use a combination of “intrinsic” signals and “extrinsic” homology appear to be leading the way toward the development of highly accurate gene prediction procedures. 

## What are “signal” sensors?
Essentially -- alignment “Models” like the ones you are already familiar with, for instance:

WMM: a weight matrix model equivalent to a  PSSM (Staden 1984)
WAM: another weight array model equivalent to a 1st order Markov model (Zhang & Marr 1993)

Could include polyA or TATA “signals” in addition to splice acceptors, splice donors, translation starts, etc.


## What are “content” sensors?
Each kind of coding and/or non-coding region can have a content bias recognizable as characteristic patterns of substring frequencies.

	              5’UTR-Exon(f)...Intron...Exon(i)...Intron… Exon(t)-3’UTR

2nd order Markov Models were first used to describe these biases
Same as 1st order with dinucleotides (for 3 base substrings)
Accounts for redundant code (3-periodicity)
5th Order Markov Models usually do a better job
Equivalent to 1st order model with pentamers (for 6 base substrings)
Detects correlations between adjacent amino acids
Even 8th order can be used!
Longer range correlations have greater discriminatory power, but eventually lead to overwhelming computational complexity.

## Example “Content” Sensor…
A “5th order” HMM for a
   coding sequence (cds) …

The lines in this diagram follow
this training sequence:

 GCTAC
  CTACA  (of 4 paths, “A” used)
   TACAG (of 4 paths, “G” used)
     123 (position in codon)

The next step: recursive return to 1st position model

Observed hexanucleotide frequencies establish the possible transition probabilities at each step, including the 4 shown here.

This HMM is “inhomogeneous” since it uses 3 different models, 1 for each codon position

## Three web-based predictors…
GeneMark.hmm
http://opal.biology.gatech.edu/GeneMark/eukhmm.cgi
GENSCAN
http://genes.mit.edu/GENSCAN.html
FGENESH
http://linux1.softberry.com/berry.phtml?topic=fgenesh&group=programs&subgroup=gfind

When possible, and if available on the website, use organismal bias parameters that are close to the source organism for your sequence.

## How do they work?
GENSCAN
5th order Hidden Markov Models
4 distinct models for regions with different %GC
Hexamer composition stats of exons vs. introns
Exon/intron length distributions
Recognition of  promoter and polyA signals
Weight matrices of splice signals and start codon region (12 bp)
Uses dynamic programming to optimize gene model using above data



## GENSCAN’s HMM
A complex net of possiblepathways !!
What if the sensors predict multiple alternative signals and alternative (overlapping) exons?

## Multiple alternative exons
This is actually very realistic!  The use of alternative signals (as in alternative splicing) 
is really quite common in genes.
How do we know which paths produce the best score on a new sequence?

## Dynamic Programming (again)
Scores for aligning exons can be built from a combination of signal and content scores.  Clearly, some exons are mutually exclusive – only compatible exons will be used.
Strong alternative paths might predict alternative gene
structures (including alternative spliced transcripts). 


## Combined Predictors
Improving FGENESH…

FGENESH+
Uses homologous protein sequence from a similar gene to find likely exons
FGENESH_C
Uses homologous cDNA sequence from a similar gene to find likely exons

         Are combined predictors really better?
Usually yes, but reference sequences need to be true homologs !

## Comparing Predictors: Sn/Sp 
Predictor sensitivity (Sn) and specificity (Sp) are usually inversely related
    -- an increase in one typically results in a decrease in the other
    -- Sn and Sp summarize true/false positives and negatives as follows:

## Sp and Sn: genes, exons, bases

## Determining Genome Sequences from Experimental Data sing Evolutionary Computation


## Introduction
## Introduction
 Bioinformatics  Analyze and exploit the information in DNA sequences
 How to generate accurate sequence data?  Challenging, important, and time-consuming
 In this chapter  Determination of DNA sequences  Advanced optimization techniques  Evolutionary algorithm

## Sequencing by Hybridization
how sequence are identified in the lab?
      DNA sequencing
            determine the sequence of nucleotides in a dna fragment of length n
sequencing by Hybridization SBH
      stage 1: Hybridization exprience DNA fragment -> spectrum
            detect all oligonucleotides (a short sequence of nucleotides) of a given length l that make up the DNA fragment
            compare the dna fragment with the oligonucleotides library (microarray chips)
      stage 2: reconstruvting the original sequence(spectrum -> sequence)
            an ideal spectrum(stage 1 is performed without errors)
            find an ordering of the spectrum elements such that neighborhood elements always overlap on l-1 nucleotides
      




## Example: Reconstruction of Sequence from an Ideal Spectrum
Original sequence (n=7)  ACTCTGG
 Oligonucleotide library (l=3)  AAA, AAC, AAG, AAT, ACA, …, TTG, TTT
 Ideal spectrum  ACT, CTC, TCT, CTG, TGG
 Reconstructed sequence
## Experimental Errors in the Spectrum
 Stage 1 usually produces errors in the spectrum  Two types of errors  Negative errors (a, b)  Miss one or more words contained in the original sequence
 Positive errors (c, d)  Contain words that are not found in the original sequence
## Formulation of the Sequence Reconstruction Problem

## How About Stage 2?
 During the reconstruction process  Negative errors  Force overlap between some neighboring oligonucleotides consisting of fewer than l-1 letters
 Positive errors  Force rejection of some oligonucleotides
 Reconstruction with errors  A strongly NP-hard combinatorial problem  Exact/heuristic methods  Restricted/unrestricted model of errors


## An Integer Programming Formulation (1)
The maximized criterion function: maximize = the number of spectrum elements composing the solution

Inequalities:
Guarantee that every element of the spectrum will be joined in the solution with, respectively, at most one element from the left side and at most one element from the right side
Equation:Ensure that in any solution, precisely two elements appear that are connected to other elements from only one side  These elements constitute the beginning and the end of the reconstructed sequence
Inequalities:
 Allow to eliminate solutions including subcycles of elements  An element in the solution that is simultaneously a successor and the immediate predecessor of another element in the solution
Inequality:
 The length of the reconstructed sequence cannot exceed its known length
## Example: Reconstruction of a Sequence from a Spectrum Containing Errors
 Original sequence (n=7)  ACTCTGG
 Ideal spectrum  ACT, CTC, TCT, CTG, TGG
 Erroneous spectrum  ACT, CAA, CTG, TCT, TGG, TTG
 Exhaustive search of potential solutions  {ACT, TCT, CTG, TGG}  ACTCTGG (the original sequence)  {CAA, ACT, CTG, TGG}  CAACTGG

## A Hybrid Genetic Algorithm for Sequence Reconstruction

## A Hybrid Genetic Algorithm for Sequence Reconstruction 
Blazewicz et al. (2002)
 Hybridized with a heuristic greedy-improvement method  Standard mutation  local search
 Gives surprisingly good results for difficult instances  Reconstructed sequences are very similar to the originals  Compared with a tabu search method

## Criterion Function and Constraint
given: a spectrum of elements(all of length l)
to find: a solutionthat maximize the number of element
      an ordering of element chosen from the spectrum, with a corresponding Reconstructed sequence
      the maximum sequence length n
            the reconstructed sequence should not be longer than n
      the general model of errors
            nothing is assumed about the types and number of the errors that may exist in the spectrum
## Flowchart of Genetic Algorithm

## Representation
 A candidate solution  A permutation of indices of oligonucleotides from the spectrum  Adjacency-based encoding
14, 21, 35, 43, 56, 62
 Example  Erroneous spectrum  ACT(1), CAA(2), CTG(3), TCT(4), TGG(5), TTG(6)
 Resulting cycle of spectrum elements  CTG(3), TGG(5), TTG(6), CAA(2), ACT(1), TCT(4), CTG(3)


## Fitness Function 
evaluate the fitness of a candidate solution
- select the best substring of oligonucleotides in the chromosome
      the largest number of elements
- the neighboring oligonucleotides are maximally overlapped
      include as many elements as possible in the substring
- normalized fitness value=the number of oligonucleotides in the substring/(n-l+1)

example
## Initial Population
 Randomly generated according to a uniform distribution  Each candidate must be a permutation of indices  Each candidate must not include any subcycle involving fewer indices than the spectrum’s cardinality  An infeasible candidate with 2 subcycles

## Genetic Operators
 Fitness  Normalized, and linear scaled
 Selection  Stochastic remainder without replacement  Elitism  Remember the best individual found in each generation
 Crossover  Greedy crossover  The first oligonucleotide: randomly
 The next oligonucleotide: the best successor  Overlap by the largest number of necleotides

## Results from Computational Experiments

## Experiment settings
 Compared with the tabu search method  The tabu search algorithm + a greedy constructive procedure for generating initial solutions
 Require similar computation times
 Parameter settings  Population size: 50  Maximum number of iterations without improvement: 20
 Environment  Pentium II 300 MHz CPU, 256 MB RAM, and Linux OS
 Spectrum  Derived from DNA sequences coding human proteins taken from GenBank
## Experiment results
# Using Genetic Algorithms for Pairwise and Multiple Sequence Alignments
## Overview
 Introduction  Methods  Results  Discussion


## Sequence Alignment

## What Is Sequence Alignment?
 Sequence alignment in bioinformatics  Compare the sequences of DNA, RNA and protein

## Why Sequence Alignment?
 Sequence alignment in bioinformatics  Identify regions of similarity  functional, structural, or evolutionary relationships A sequence alignment between two human zinc finger proteins
 Identity: conserved region  structural or functional importance  Substitution: point mutation  Gap: insertion/deletion mutation
Tuesday, December 13, 2016
diverge from a common

## How To Solve?
 Very short or very similar sequences  can be aligned by hand
 Lengthy, highly variable or extremely numerous sequences  cannot be aligned solely by human effort
human knowledge
construct algorithms to produce high-quality sequence alignments
 Dynamic programming  Slow but formally optimizing
 Heuristic or probabilistic methods  Efficient for large scale search

## Multiple Sequence Alignment
First 90 positions of a protein multiple sequence alignment of instances of the acidic ribosomal protein P0 (L10E) from several organisms, from Wikipedia.
## The Multiple Sequence Alignment (MSA) Problem Introduction
 Multiple sequence alignment  Simultaneous alignment of many nucleotide or amino acid sequences
 Line up the characters in a set of strings in the best possible way  How to line up?  Insert gaps into the strings to make equal length
 What is best?  Score an alignment of multiple sequences

## How To Line Up? (1) 
 Given a family of sequences of various length


 To compute an alignment of sequence family

## Representation
 A 2D binary matrix  a candidate alignment  A row vector bi  A sequence
 A bit bi,j  Insert a gap into position j of sequence I

## An Example


## What Is Best? (1)

Score between any two sequences
 Score an alignment of multiple sequences  Sum-of-pairs score (SP-score)
 The MSA problem  To find an alignment that maximizes SP-score
## Related works
 Progressive approach (CLUSTAL W, Feng and Doolittle)  Advantage  Speed, simplicity and sensitivity
 Disadvantage  Local minimum  greedy nature  No objective function  quality measure
 Hidden Markov model (HMM)  Advantages  A sound link with probability analysis
 Disadvantages  Limited to cases with 100+ sequences

Objective functions (OFs) approach  Advantages  Quality measure  find the best
 Disadvantages  Astronomical number of possible alignments?
 S1: MSA program  Advantages  Find the best alignment in a reduced space
 Disadvantages  Still limited to small examples

Objective functions (OFs) approach  Advantages  Quality measure  find the best
 Disadvantages  Astronomical number of possible alignments?
 S2: Stochastic optimization methods  Simulated annealing: very slow  alignment improver  Gibbs sampling: non-gapped alignment only  Genetic algorithms: dynamic programming/GA hybrid

## In this paper…
 SAGA: sequence alignment by genetic algorithm  Find globally optimal multiple alignments in reasonable time  As good as or better than MSA, CLUSTAL W  Measure: OF score, reference alignments
 Optimize any objective functions (OF) one can invent  OF: what is the best in real sense  the key to success


## Methods
Use an OF as quality measure, and 
 Optimize it using a genetic algorithm
## Objective function (OF)  OF: what is best?
 COST(Ai, Aj): substitution/gap cost  Wi,j : the weight (similarity) of sequence pairs (i,j)  MSA: phylogenetic tree  CLUSTAL W: a weight  each sequence
 In this study,  OF1: pam250 substitution + quasi-natural gap + MSA rationale 2 weight  OF2: pam250 substitution + natural gap + CLUSTAL W weight
## Sequence alignment by genetic algorithm (SAGA)
 Population  Made of alignments
 Fitness  Measured by the OF
 Operators  Each has a probability of being chosen  dynamically optimized during the run
 Help the population to improve by creating the children it needs

## SAGA: pseudo-code
 Initialization  Population size = 100  Randomly created  Random offset  sequence  move to the right
 Evaluation  Fitness (OF)  expected offspring (EO)  EO: a probability for each individual to be chosen as a parent (0~2)
 Breeding  Overlapping generation  50% (fittest individuals): survive unchanged
Breeding - 50% (remaining)  Select parents  Weighted wheel selection (EO-based)
 Modify parents: several operators  Each has a specific probability of being used
 Absence of duplicates  Maintain population diversity
 End  Stopping criterion: stabilization  Unable to improve for some specified number of generations
## The operators in SAGA
 Two types of operators  Crossover  Merge parent alignments  Two parents  one child
 Mutation  Modifications  One parent  one child

## One point crossover
 Cut P1 randomly  Tailor P2  Join P1 and P2  P1.left+P2.right=C1  P2.left+P1.right=C2  Gaps  junction point (disruptive)
 Keep the best of C1 and C2

## Uniform crossover Promote exchanges between zones of homology
 Map consistent positions between P1 and P2  C=P1.left+P2.mid+P1.right (semi-hill climbing /stochastic?)


## Gap insertion Generate new patterns
phylogenetic tree
 Split sequences into two groups  G1: seq1, seq2  G2: seq3, seq4, seq5
 For G1,  Choose P1 randomly (semi-hill climbing /stochastic?)
 Insert a gap of length 2 at P1
 For G2,  Choose P2 within a maximum distance from P1
 Insert a gap of length 2 at P2

## Block shuffling Shift a gap to the left or to the right
 Move a full block of gaps/residues

 Split the block horizontally/vertically , and move part
 The position to move  Semi-hill climbing/stochastic?

## Block searching Speed up generating more dramatic changes
 Given  An initial substring in one of the sequences  Random position/length
 To  Find the block to which it may belong  The best matching substrings in all the remaining sequences  Move the sequences to reconstruct the block


## Local optimal or sub-optimal rearrangement To overcome the problem of local minimum
 Optimize the pattern of gaps inside a given block  By exhaustive examination of all gap arrangements inside the block  Require <2000 combinations to examine
 By a local alignment GA (LAGA)  One point crossover + block shuffling  Number of generations = 10 × number of sequences  Population size = 20

## Dynamic scheduling of the operators
 A total of 22 operators  2 crossover + 2 gap insertion + 16 block shuffling + 1 block searching + 1 local/sub rearrangement
 Each operator has a probability of being used  Initialization: all the same = 1/22  The probability of an operator is optimized on the run  A function of the efficiency (improve alignments)
it has recently (10 last generations)  Credit  shared with the operators that came before
 Taken as usage probability and remain unchanged until next assessment  Minimum probability = 1/44  to avoid the loss of operators

## Test cases
 A set of 13 test cases  Based on alignments of sequences of known tertiary structure  Various length (60-280) and numbers (4-32) of sequences
 Mathematically optimal/sub-optimal  Group 1: 9 cases  Small alignments (4-8 sequences, 60-280 residues)  Can be handled by MSA  Compare MSA with SAGA using OF1
 Group 2: 4 cases  Large alignments (9, 12, 15 and 32 sequences)  Cannot be handled by MSA  Compare CLUSTAL Wwith SAGA using OF2
 Biological relevance  Compare SAGA, MSA and CLUSTAL W with reference structural alignments


## Results

## Self tuning ability 
Automatic scheduling of the operators (one point/uniform crossover)
 Two types of crossover are competing with each other

Semi-hill climbing/stochastic operators behave in a complementary way
## Optimization of OF1 Compare SAGA and MSA
 SAGA is able to produce a score at least as good as that produced by MSA (optimization + accuracy)

## Compare SAGA and CLUSTAL W
 SAGA performs more accurately than CLUSTAL W on data sets of realistic size
SAGA accurately finds the main features
 12 completely conserved positions  SAGA: 11  CLUSTAL W: 10
## Discussion

## SAGA: a powerful and flexible tool
 Advantages  The ability to achieve optimal alignment scores (mathematically)  The consistency of alignments with test cases of known tertiary structure (biologically)  the usefulness of OFs
 Disadvantages  Still fairly slow for large test cases (>20 sequences)  Combine the speed of progressive approach with the accuracy of genetic algorithm (hybrid)

##  Starting population
 Currently, seed alignments completely randomly  Use heuristic alignments generated by CLUSTAL W  Could be trapped in local minima
 SAGA as an alignment improver  Starting alignment  close to the optimal solution  Generate hybrid alignments for very large test cases

## Efficiency of GA
 Use a large number of mutational and crossover operators, and automatically schedule them  Complicated and cumbersome?  MSA is not a simple problem
 The most useful operators  Based on biological reality (e.g. moving blocks using the tree as a guide)
 Automatic scheduling  New situation/problem  new operators  Usefulness or redundancy at different stages
 Implement and test any OF one can think of  A good measure of quality  key to success

## Questions after sequence alignment
 Q1: Is the alignment significant with respect to some statistical model?  A very difficult problem which has solutions for two sequences under certain conditions
 Q2: How stable is the alignment or which pieces of the alignment are stable?  Important to interpret new alignments and there are solutions for just two sequences

# Introduction to Support Vector Machine (SVM)

## Introduction -- SVM classification
 Support vector machines (SVMs) developed by Vapnik, have gained wide acceptance because of their high generalization ability for a wide range of applications.
 There are many variations of SVM, including the soft margin classifier, adaptive margin classifier, and so on.
 Even though the two classes divided by the margin are slightly overlapped and noise exists, they all have the common property that the constructed hyper plane effectively separates two classes.


# Quasi-linear Support Vector Machine for Nonlinear Classification

## Introduction 
 Support Vector Machines (SVMs) have been widely used in different application areas including pattern recognition, computer vision and bioinformatics.

SVMs can deal with linearly inseparable classification problems by mapping the input data onto a higher-dimensional feature space , and the feature mapping can be done implicitly through the kernel trick.
## Nonlinear Classification Problem 
## Quasi-linear Regression Model 
##  SVM Identification Approach 
## Implementation 
## Experiments
##  Conclusions

# Gene Function Prediction Using SVM
>> Multi-label Classification Based on Label Ranking and Delicate Boundary SVM
## Gene Function Prediction
 The completion of several genome projects in the past decade has generated the full genome sequence of many organisms. Assigning biological functions to the sequences has become a key challenge in modern biology.
 Machine learning techniques are often used to predict gene functions from a predefined set of possible functions. Afterwards, the predictions with highest confidence can be tested in the lab.

# Brief Introduction to Estimation of Distribution

## Evolutionary computation (EC) as a robust search technique.
 Evolutionary computation such as genetic algorithms (GAs) is considered a promising approach to realize robust search algorithms.
 They can be applied wide-spectrum of application problems to support human innovation processes.

## Classical v.s. modern approaches for EC
 Classical approaches: simply imitate natural evolution processes.
(simple) GA, ES, EP, GP, and so on.
 Modern approaches: more sophisticated mechanisms are installed. Linkage identification, Linkage learning, Estimation of distribution algorithms (EDAs)

## “Linkage problem” in genetic and evolutionary computation
 Building Block (BB) mixing is a major source of optimization power in GECs.
 Classical GECs such as Simple Genetic Algorithms (SGAs) become inefficient when tight encoding is not ensured.
 This is because simple crossovers disrupt useful BBs easily in such situation.

## Estimation of distribution algorithms (EDAs)
 A novel approach in Genetic and Evolutionary Computation (GEC)
 A promising approach to solve the “linkage problem” in GEC.
 It estimates probabilistic distribution of “good” solutions, which is employed to make offsprings for the next generation.

## A brief history of EDAs
 PBIL (Population-Based Incremental Learning)
 UMDA (Univariate Marginal Distribution Algorithm)
 BMDA (Bivariate Marginal Distribution Algorithm
 FDA (Factorial Distribution Algorithm)  BOA (Bayesian Optimization Algorithm)

##  Estimation of Distribution Algorithms (EDAs)
1. 2. 3. 4. 5.
Randomly initialize a population consisting of N strings (solutions).
Select M (<N) strings based on their fitness values.
Build a probabilistic model based on the selected strings.
Generate a new population of N strings based on the model.
Unless a terminate criterion is satisfied, go to 2.

## Overview of EDAs (BOA)

## Bayesian Optimization Algorithm (BOA)
 Build a probabilistic model based on Bayesian network model
 The optimal network model is obtained by minimizing the BayesianDirichlet (BD) metric calculated from distribution of alleles in strings selected from a population.
 The minimization of the metric is calculated by a local search technique.

## Fitness signal differences are not effectively utilized in EDAs
 In EDAs, a simple thresholding scheme is employed to select strings.
 There is no difference among the selected strings in building probabilistic models.
 Fitness differences among them are not effectively utilized.

## Introducing assignment functions to EDAs
 We introduce the following assignment functions into EDAs to assign weights to calculate the metric more accurately.
 A rank-based assignment function assigns weights based on fitness rank.
 A roulette-wheel assignment function is calculated by normalized fitness values (similar to roulette-wheel reproductions).

## A rank-based assignment function for EDAs

## A roulette-wheel assignment function for EDAs
 Calculates normalized fitness values by the following equation:

 We may use scaling to control selection pressure.


## EDA with assignment functions (without explicit selections)

## Numerical experiments
 We introduce assignment function to the Bayesian Optimization Algorithm to be compared with its original version without AF.
 We employ the following test functions usually employed in GA researches:  The sum of ３-bit trap functions  The sum of 5-bit trap functions
 We measure time to obtain optimal solutions by changing problem size.

## Assignment functions (AF)
 We employ the following assignment functions

## A 3-bit trap function

## A 5-bit trap function

## A weighted 5-bit trap function

## Real time comparisons
 Exponentially-scaled 5-bit trap function (90 bit) is employed to compare time to obtain an optimum.  Original BOA  BOA with roulette-wheel AF
 We employ SGI Onyx300 consisting of MIPS R1400/500MHz x 32 with 16GB shared memory

## Time to obtain solutions

## Conclusions
 We introduce assignment functions (AFs) into EDAs to improve accuracy in their mode-building process.
 BOA with AFs can improve optimization performance with less computational overheads.
 The experimental results show BOA with roulette-wheel AF is the best.



## The No Free Lunch (NFL) Theorem for Optimizations  The theorem indicates that average
performances of all search algorithms for all possible problems are the same!

## Implications of NFL theorem
 Random search can solve all possible problem with equal computational cost, but it is extremely inefficient.
 Problem specific methods tailored to solve some problems class must achieve high performance, but can be applied to the limited ones.
 “Robust” algorithms (such as evolutionary algorithms) can solve relatively wide spectrum of problems with moderate computational cost.

## Computational power and search algorithms
 If we have infinite computational power, we can use random (or enumerative) search (apparently impractical).
 In the early history of computers, problem specific methods are reasonable to employ because computers are very costly and we can use limited computational resources.
 Now, we have powerful computers, and we can employ robust algorithms which needs moderate computational cost.


## We do not need to solve “all possible” problems!
 In the “all possible” problems, there are a number of instances which we do not need to solve practically.
 “A-needle-in-a-haystack” problem is one of such problems.

## Our grand challenge: designing automated innovations
 We seek for search algorithms applicable to wide spectrum of (difficult) application problems with moderate computational overheads.
 Such robust search algorithms could be an alternative of some low-level human innovation processes (with trials & errors).

## uadratic :
  The sum of k-bit trap functions 

A string s consists of substrings si (i=1,2,…,L) which is not necessary to be tightly linked.

# Protein Structure Prediction Using Hybrid EDA
>> Protein Structure Prediction on HP Model Using a Hybrid EDA
## Protein Structure Prediction
 The protein structure prediction (PSP) problem is one of the most important problems in computational biology.
 Understanding protein structures is vital to determining the function of a protein.

The biological method (X-ray crystallography and Nuclear Magnetic Resonance (NMR) spectroscopy) is a slow and expensive process.
 While there are over a million known protein sequences, only a limited number of protein structures are experimentally determined.
Anfinsen's thermodynamic hypothesis (1972, the Nobel prize): the native structure of protein is determined by its amino acid sequence. Under the environmental conditions (temperature, solvent concentration and composition, etc.), the native structure is a unique, stable and kinetically accessible minimum of the free energy. This hypothesis forms the basis for computational prediction of a protein’s conformation from its residue sequence.
## Protein HP Model
 Simplified model: HP-lattice model . A tool for investigating general properties of protein folding.
 Two types of residues: hydrophobic and polar

Simplified model: HP-lattice model .  Score (energy): the number of HH topological neighbors (adjacent either in the lattice but not connected in the chain).

ptimization task of finding the solution that minimizes the total energy.
 Challenges and difficulties:
NP-complete problem; Long sequence folding; Invalid individuals.


## Motivations
 The EDAs based on Markov probabilistic model [R.Santana, 2008] outperforms other population-based methods.
 Problem representation: internal coordinates with relative direction. For 2-D: left, right and forward (L, R, F). For 3-D: left, right, forward, up and down, (L, R, F, U, D).


## Estimation of distribution algorithms (EDAs)

## Motivations
roblems of the existing EDA based methods. Motivations
Long length sequences
Can not find the global optimum solutions.
Invalid individuals
The computational cost of traditional backtracking repairing procedure is very heavy for long sequence instances
## Proposed Hybrid EDA for HP Model
Composite fitness function. 
It is well know that the energy potential in the HP model reflects the
fact that hydrophobic residues have a propensity to form a hydrophobic core (H-Core) [Md Tamjidul,2006]. The Hs (hydrophobic residues) form the protein core and the Ps (hydrophilic or polar residues) tend to remain in the outer surface. The H-Core Center is called HCC.

 The size of H-Core is an important characteristic for the
folding structure of individual.

Local search with guided operators. Local search with a set of guided operators is implemented
in the proposed hybrid EDA.
## Improved Backtracking-based Repairing Method
 Drawback of basic backtracking repairing procedure For the long sequence protein, there are many closed-areas
(or closed-spaces in 3-D circumstance) in folding procedure.
 A detection procedure is added to avoid entering an invalid closed area when select directions for residues.
## Experiments
HP benchmark. The first nine instances of the Tortilla 2-D HP benchmarks,
and the last two instances are taken from Ref. [R.Santana, 2008].

Experiment setting.  k-order Markov: k = 3;  Population size: 5000;  Truncation selection: T = 0.15;  Generation : 3000;  Early stop: the number of different individuals in the population falls below 5.

Results of comparing with MK-EDA for 2-D HP model.
Results achieved by different search methods for 3-D HP model.
The best fitness for one representative run of instance S7.

comparing experiments for long sequence protein prediction s6 to s10 in 2-D HP model (population:1000, generation:100, the truncation selection of parameter T=0.15, CPU-Times of 10 runs ).

The number of backtracking searching operations.


## Summary
1) A composite fitness function containing the information of folding structure core (Hcore) is introduced to select better individuals for probabilistic model of EDAs.
2) Local search with guided operators is utilized to refine the found solutions for improving efficiency of EDA.
3) An improved backtracking-based repairing method is introduced to repair invalid individuals sampled by the probabilistic model of EDAs for the long sequence protein instances.


## Protein Structure Prediction
>> Protein HP Model Folding Based on Adaptive Niching EDA with Balance Searching
## Motivation
 For the optimization problems with irregular and complex multimodal landscapes, the EDAs still suffer from the drawback of premature convergence similar to other Evolutionary Algorithms (EAs).
 Finding a modifiable balance between exploration and exploitation is a key to this issue.

## Proposed Adaptive Niching EDA
 The clearing procedure is used as a basic niching frame in the proposed adaptive niching EDA.


## Proposed Adaptive Niching EDA
Exploration VS. Exploitation
The clearing radius are determined adaptively by AP clustering during a run of EDA. A cluster can be seen as a niche. A niche capacity selection mechanism based on the Boltzmann scheme is utilized to realize a balance searching.

## Mechanism of Niche Capacity Selection
 The niche capacity selection is utilized to tune the searching behavior of EDA.

## Exploration Probability
Irregular niche distribution problem. The population clustering information can be used to record the EDA searching history

A niche novelty metric is proposed to record the overlapping information, and it is used to evaluate the degree of the corresponding niche explored by the previous searching.

A popular fitness-proportionate method is used as the exploitation strategy in the proposed adaptive niching EDA. It is defined based on the best fitness value in a niche. It can guide the EDA to search the already found promising areas of searching space.

## Proposed Adaptive Niching EDA


## Simulations on Continuous Optimization
Three benchmark functions from [X. Yao,1999] are used to evaluate the proposed method.

## Simulations on Continuous Optimization
 The maximal evaluation number : 4 × 105 (population: 1000 and generation: 400);
 Gaussian probabilistic model ; Truncation selection size of 500;  Parameters of the proposed selection mechanism: α= 2 and β= 0.95;
 Similarity metric in AP clustering: Euclidean distance;  Repairing invalid individuals: set to the bound value;  30 independent runs.

## Simulations on Continuous Optimization
Simulation results.
A complicated discrete EDA optimization problem, the HP model protein folding based on a k-order Markov probabilistic model.
## Simulations on Protein HP Model
 The maximal evaluation number : 2 × 106 (population: 2000 and generation: 1000);
k-order Markov model (k=3); Truncation selection size of 300;
 Parameters of the proposed selection mechanism: α= 1 and β= 0.80;
Repairing invalid individuals: improved backtracking-based repairing method ;
 Similarity metric in AP clustering: Hamming distance.

The results of compared with the MK-EDA for the 2-D HP model.

The results of compared with the Hybrid-EDA for the 2-D HP model.
## Summary
1) An adaptive niching EDA is proposed, AP clustering is used to adaptively partition the population into niches during a run of EDA.
2) A mechanism of niche capacity selection based on the Boltzmann scheme is proposed to realize a balance searching between exploration and exploitation.


## Conclusions
1) A hybrid EDA can be used for solving the protein structure problem on HP model.
2) An adaptive niching EDA with balance searching based on clustering analysis can be used to enhance the performance of EDA.

## 

## 

## 

## 


## 

## 

## 
## 

## 


## 

## 

## 
## 

## 


## 

## 

## 
## 

## 


## 

## 

## 






























































